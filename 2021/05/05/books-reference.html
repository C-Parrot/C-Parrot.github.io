<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>书籍reference | </title><meta name="author" content="pilotqvq"><meta name="copyright" content="pilotqvq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="提前声明：以下内容摘录自豆瓣与知乎。 除非你对计算机有很大兴趣，还比较勤奋，想做个优秀的工程师，否则所有这些大部头你都不用看 O’Reilly出版社，出的书都比较慢、慢。Manning出版社 （一）互联网书籍 1.《失控》凯文.凯利——主要介绍的是碎片化思维和生态系统 2.《长尾理论》克里斯·安德森——“垂直”产品占到的市场份额，会越来越大 3.《认知盈余》克莱·舍基——每个人的自由时间看成一个集">
<meta property="og:type" content="article">
<meta property="og:title" content="书籍reference">
<meta property="og:url" content="https://c-parrot.github.io/2021/05/05/books-reference">
<meta property="og:site_name">
<meta property="og:description" content="提前声明：以下内容摘录自豆瓣与知乎。 除非你对计算机有很大兴趣，还比较勤奋，想做个优秀的工程师，否则所有这些大部头你都不用看 O’Reilly出版社，出的书都比较慢、慢。Manning出版社 （一）互联网书籍 1.《失控》凯文.凯利——主要介绍的是碎片化思维和生态系统 2.《长尾理论》克里斯·安德森——“垂直”产品占到的市场份额，会越来越大 3.《认知盈余》克莱·舍基——每个人的自由时间看成一个集">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/书籍/QQ截图20210312180709.png">
<meta property="article:published_time" content="2021-05-05T08:56:03.000Z">
<meta property="article:modified_time" content="2021-05-13T07:32:56.322Z">
<meta property="article:author" content="pilotqvq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/书籍/QQ截图20210312180709.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://c-parrot.github.io/2021/05/05/books-reference"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"HPFFJ9C6DB","apiKey":"78e3e87b096c5c0bff76287be921d775","indexName":"pilotqvq","hits":{"per_page":6},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '书籍reference',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-13 15:32:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/hexo相关/无职转生.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">书籍reference</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2021-05-13T07:32:56.322Z" title="undefined 2021-05-13 15:32:56">2021-05-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">21.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>65min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="书籍reference"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>提前声明：以下内容摘录自豆瓣与知乎。</p>
<p>除非你对计算机有很大兴趣，还比较勤奋，想做个优秀的工程师，否则所有这些大部头你都不用看</p>
<p>O’Reilly出版社，出的书都比较慢、慢。Manning出版社</p>
<p><strong>（一）互联网书籍</strong></p>
<p>1.《失控》凯文.凯利——主要介绍的是碎片化思维和生态系统</p>
<p>2.《长尾理论》克里斯·安德森——“垂直”产品占到的市场份额，会越来越大</p>
<p>3.《认知盈余》克莱·舍基——每个人的自由时间看成一个集合体，一种认知盈余，那么，这种盈余会有多大</p>
<p>4.《激荡三十年》吴晓波 ——社会以不可逆转的姿态向商业社会转轨</p>
<p>5.《从0到1》彼得.蒂尔——详细阐述了作者自己的创业历程与心得，包括如何避免竞争、如何进行垄断、如何发现新的市场</p>
<p><strong>（二）做事方法类书籍</strong></p>
<p>1.《精益创业实战》Ash Maurya——一个系统的流程来快速检查各种产品理念，提高做事成功率</p>
<p>2.《卓有成效的管理者》德鲁克——管理者的成效往往是决定组织工作成效的最关键因素</p>
<p>3.《参与感》黎万强——“米粉”热情饱满地参与到小米发展的各个细节当中</p>
<p>4.《创业时，我们在知乎聊什么》知乎——知乎三年创业问答精华大集结</p>
<p>5.《结网-第二版》王坚 ——总结了产品经理知识体系</p>
<p> <strong>（五）学习提升类</strong></p>
<p>1.《超级快速阅读》 格吕宁 ——如何快速阅读获取知识</p>
<p>2.《麦肯锡教我的写作武器》 高杉尚孝 ——工作中如何写作</p>
<p>3.《精要主义》 格雷戈·麦吉沃恩 ——工作生活中如何选择</p>
<p>4.《金字塔原理》 巴巴拉·明托 ——工作生活中如何思考</p>
<p>5.《好好学习》 成甲——工作生活中如何学习</p>
<p><strong>产品经理的必读书籍</strong></p>
<p>1.《瞬间之美》Robert Hoekman.Jr——针对Web应用中几乎所有相关元素提出了值得借鉴的解决方案</p>
<p>2.《Don’t make me think》克鲁格——特别适合为如何留住访问者苦恼的网站/网页设计人员阅读</p>
<p>3.《交互设计精髓》库伯——全面系统地讲述交互设计</p>
<p>4.《用户体验度量》特里斯——如何量化用户体验对有效提高产品的可用性而言至关重要</p>
<p>5.《人人都是产品经理》苏杰 ——写给“-1到3岁的产品经理”的书，涉及到：用户、需求、项目、团队、战略、修养</p>
<p>6.《设计心理学》诺曼——不是你没有设计好，只因为你没有了解用户的使用心理</p>
<p><strong>营销类必读书籍</strong></p>
<p>1.《引爆点》马尔科姆·格拉德威尔——流行的趋势需要一个发展的温床</p>
<p>2.《异类》马尔科姆·格拉德威尔——指出了成功之路的方向，但怎样把握这份机遇，每个人都需要仔细思考</p>
<p>3.《流量的秘密》Brian Clifton——花出去的钱到底是带来了收益，还是看不见的损失</p>
<p>4.《一个广告人的自白》大卫·奥格威——详解能够使一家广告公司获得成功的方法</p>
<p>5.《眨眼之间》马尔科姆·格拉德威尔——我们在一眨眼之间作出的决定，比三思而后行，或许更具大师级的水准</p>
<p>6.《定位》艾.里斯——深入阐述了定位理论和操作方法，并配有丰富的实战案例解析</p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="计算机体系结构：量化研究方法"><a href="#计算机体系结构：量化研究方法" class="headerlink" title="计算机体系结构：量化研究方法"></a>计算机体系结构：量化研究方法</h3><h3 id="计算机组成与设计：硬件-软件接口"><a href="#计算机组成与设计：硬件-软件接口" class="headerlink" title="计算机组成与设计：硬件/软件接口"></a>计算机组成与设计：硬件/软件接口</h3><p>看了一下翻译，决定读原版。 习题答案及拓展阅读以上传至github，大家可以Star我的仓库并在Issues界面讨论 <a target="_blank" rel="noopener" href="https://github.com/xueb96/C_O_D_5th">https://github.com/xueb96/C_O_D_5th</a></p>
<p>以32位MIPS精简指令集为基础讲解处理器，比较优秀的教材；进阶版《计算机组成与设计：量化研究方法》；建议留英语原版电子版备查；作者现在是图灵奖获得者了</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/1.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/2.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/3.png"></p>
<p>​           <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/4.png">                    </p>
<h3 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h3><p>这本书很庞杂的，很多东西还要找其他参考书借鉴</p>
<p>不过于展开细节，课时被压缩了，很多东西肯定都讲不清楚的，还得钻研其他的书</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/5.png"></p>
<p>不看这本，看软硬件接口，看操作系统概念，看完再回来看这本你会发现已经差不多了</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/6.png"></p>
<p>CSAPP是一本很基础的书.糅合了计算机组成原理,操作系统,体系结构,网络编程,并行程序设计原理等课程的基础知识. 这是一本方向性的书,</p>
<p>CMU  卡内基梅隆大学</p>
<p>　CMU是全美以至全球公认的CS最猛的大学之一，没办法，作为CS的发源地，再加上三位神一样的人先后在此任教：Alan Perlis（CS它祖宗+第一届Turing奖获得者）、Allen Newell（AI缔造者+Turing奖获得者）和Herbert Simon（AI缔造者+Turing奖获得者+Nobel经济学奖获得者，当代的Leibniz，偶佩服到死的一个天神下凡级的人物，他的自传 Models of my life偶特意珍藏了两本），三位巨头培养出一大摊小神级别的人物，这一大摊小神级的人物又培养出一大坨天才级人物（其中就有跳槽猥琐男开复哥）。</p>
<p>偶在本科时曾经有过一个疑问，那就是作为一个程序员，究竟需要对计算机的硬件了解到什么程度呢，或者说，算法、数据结构和程序设计语言之外的东东，我们是否有必要了解，需要了解到什么程度呢？</p>
<p> * 至今记得学习计算机组成原理时，老师在上面拿着某个疑似打字机的东东给我们一顿演示，说这就是什么可编程逻辑器件，然后给我们展示了各种电路图，总之偶是看不明白，也想不明白这些与非门或非门异或门***门xx门会对偶编程序有什么帮助，</p>
<p> * 之后学习编译原理，偶承认写个语法制导的小型翻译器是挺磨练人的编程水平的，但符号流，语法制导，语义分析这些东东实际中的效用有多大，偶真没感觉到。至少偶身边没人用语法制导写interpreter，编译原理对偶的作用就是大大简化了学正则表达式的过程，除此之外，别无它用（别鄙视偶）。</p>
<p> * 至于操作系统，偶学完了之后脑子中除了进程和局部性这两个概念之外，可以说是一片空白，偶觉得，既然OS的设计初衷就是为程序员提供一个可编程易理解的通用接口，那我们为什么还得去把这个接口扒开然后去研究诸如硬盘的磁道有几圈寻道时间有几毫秒此类的问题，a fucking waste of time。</p>
<p>即使是在CS中，80/20原则依然适用，程序员平时用到的超过九成的计算机知识基本来自于这些计算机核心课程中的不到一成的内容，至于剩下的九成内容，虽然不至于没用，然而它们没有大用，至少，它们不会对你造成什么损害。举个例子，你可以不知道DMA的原理，不知道BNF范式，你依然可以编出不错的程序；但是如果你连内存布局分配或是同步限制区都不清楚的话，那就囧大了，要不然你就会在为什么不能初始化一个大小为16MB的局部变量这样的 NC问题上纠结半天，或者是对着多线程程序里变幻莫测的全局变量百思不得其解。<br> 　所以说CMU的两位作者以及CSAPP这本书背后的劳动者和贡献者是非常NB的，他们非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存这一摊来自各不同的学科的核心知识点搅和在一起，并以程序员的视角呈现，所以这本书的书名叫A programmer’s perspective。</p>
<p>曾经有人说过这本书名（指的是中文译名）不副实，讲解的并不深入。的确，这本书虽然涉及了计算机学科的各个方面，然而很多东西都是点到为止的感觉，作者的意思也很明确，这本书属于导论的性质（CSAPP对应CMU的 Introduction to computer systems这门本科课程，属于导论性质）。按照国内CS的课程安排的话，CSAPP介于计算机组成原理和操作系统之间，它的目的就是让你对这些计算机的基础学科有一个Overview，并尽可能的把作为一个程序员所必须了解的那些essence：那不到一成的计算机核心知识，尽早的灌输给你。</p>
<p>Acronyms:<br> 　<br> 　 * CS=Computer Science<br> 　 * CMU= Carnegie Mellon University<br> 　 * CSAPP=Computer Systems A Programmer’s perspective<br> 　 * VM= Virtual Memory<br> 　 * PTE= Page Table Entry</p>
<p>* 这本书的简介（引言）部分简介明了：一个简单的hello world程序在计算机上的执行过程，<strong>预处理**</strong>-&gt;<strong><strong>编译</strong></strong>-&gt;<strong><strong>汇编</strong></strong>-&gt;<strong><strong>链接</strong></strong>-&gt;<strong><strong>生成可执行目标文件</strong></strong>-&gt;<strong><strong>载入内存</strong></strong>-&gt;<strong><strong>数据流</strong></strong>-&gt;**<strong>屏幕输出显示</strong>，没有一句废话，简介扼要，总结成一句：计算机系统=位+上下文。</p>
<p> * 关于二进制的内容个人感觉有些冗余，这部分内容偶基本是一扫而过，毕竟从小到大这些内容学了都快有十多遍了，而平时编程真能用到的二进制技巧基本也就移位和bit flag这两招。不过这章里有不少small tricks值得一耍（最经典的就是不用临时变量交换两个数）。话说回来，真要想在二进制上玩出花来，参考Hacker’s delight会有更大的惊喜。</p>
<p> * 程序的机器级表示这一章偶花了不少时间阅读，毕竟偶没学过汇编，基础基本为0。不过这本书里出现的汇编指令绝大多数都由运算、取数存数、跳转这三种指令所组成，所以在阅读上不会存在任何难度。<br> 　这部分融合了程序员所需了解的编译和汇编这两样课程中的基础知识：想知道for、do..while、while三种循环的实质性区别？想知道多重if和 switch的本质区别？想知道数组的存储方式？想知道数组下标读取和指针读取的区别？想知道递归过程调用的背后实现机理？看看这一章，相信你会对C语言乃至程序设计语言有更深的理解。</p>
<p>当然，要想深入学习的话，好书有的是，OS有Tanenbaum老爷子的Modern operating systems，计组有Stanford校长的量化研究和软/硬接口，编译自然就是Aho的龙书，链接可以参考Levine的 Linkers&amp;Loaders，程序设计语言原理可以阅读Scott的Programming language pragmatics。如果需要更多的资源，可以参考CSAPP书后的Bibilography。</p>
<p>CMU15-213的<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~./213/schedule.html">课程主页</a>，有ppt，代码还有录像</p>
<p>213是众多课程的先修要求。至于15213的先修课程则是122使用C0语言教学（C语言的一个子集）<a href="https://link.zhihu.com/?target=http://www.cs.cmu.edu/~rjsimmon/15122-s16/schedule.html">15-122 S16。 </a>如果没有编程基础则可先修15112，使用Python教学（<a href="https://link.zhihu.com/?target=http://www.cs.cmu.edu/~112/schedule.html">15-112 Schedule (Fall 16)</a>）。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/7.png"></p>
<p>勘校表<a target="_blank" rel="noopener" href="http://www.yiligong.org/csapp3e/">http://www.yiligong.org/csapp3e/</a></p>
<p>我觉得吧，直接上手lab，</p>
<p>除了第4章没看和malloc lab没做，前前后后大概花了8个月的时间了吧。</p>
<p>那就拿第二个lab bomblab来说吧. 不用担心不知道如何开始，直接去官网下lab，里头配套提供了非常详实，细节的handout，你把handout看明白，然后去看对应书中相关章节，边做lab边参考书。你有目标要把lab做出来，你自然会有动力去学习。</p>
<p>下载self-study handout不需要密码 这个里面就有lab</p>
<p>也就是说只能下载handout呗   所有实验题目和自动打分程序都提供的</p>
<p>15513的ppt和lecture提炼的很好，基本把书中最干活最重要的内容包含进来了。相比于看书可能能节省不少时间。</p>
<p>这门课一共有6个lab。</p>
<p>Data Lab：bit 运算与float的相关操作</p>
<p>Bomb Lab：阅读汇编破解密码</p>
<p>Attack Lab：Buffer Overflow 攻击</p>
<p>Cache Lab：实现一个cache simulator已经一个cache efficient的矩阵转置。</p>
<p>Shell Lab：用多进程实现一个简单的linux shell。主要是熟悉进程控制与同步。</p>
<p>Malloc Lab：自己写一个C语言的malloc函数。</p>
<p>Proxy Lab：写一个支持HTML的多线程Server。熟悉Unix网络编程与多线程的控制与同步。</p>
<p>个人感觉收获比较大的是Shell Lab和Proxy Lab。因为线程，进程的控制与同步，光看视频或者教科书可能印象不是很深。可是一旦自己实现了就会对这个块内容理解地更加透彻。这里赞一下CMU的Autolab,每次作业都会提供很多测试用例。Handout也写得很详细，会告诉很多debug的方法与工具。</p>
<p>《Hardware/Software Interface》</p>
<p>华盛顿大学每个学年都会更新课程放到网上： <a target="_blank" rel="noopener" href="https://courses.cs.washington.edu/courses/cse351/">https://courses.cs.washington.edu/courses/cse351/</a></p>
<p>我们老师作为这本书国内出版序言的作者是这样说的：<br> 程序员的视角这句话本身就是让你不要太在乎底层具体电路。你只需要在这个层面上把上层建筑优化好。否则作者取名就应该是EE的视角。<br> 并不是越底层就越好，了解底层的目的是为了能够对于上层有所帮助。而CSAPP这本书+现代操作系统已经足矣，再往下的硬件就没必要深究了。<br> 虽然说学的多不是坏事，但是人的精力是有限的，同样的时间，对于一个programmer来说，可能具体数学或是COM会更有用一些。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>初学软件设计最好不要先看书，或者说可以大概看看，但不要认真。</p>
<p>一般设计初学者最喜欢干的事情，就是直接读GoF这种的书，自以为天下的设计模式只有23种，然后拿着这23个锤子去满世界找钉子。</p>
<p>设计的精髓在于“<strong>在多个相互矛盾的目标中找到权衡</strong>”。设计的上下文对设计非常的重要，上下文变一点点，都有可能造成设计方案完全不同。</p>
<p>如果一定要有个入门，我觉得比较好的方案是：</p>
<p>在你工作的领域中，找到最常用的设计模式。比如做Web的，MVC、MVVM这类应该很常见</p>
<p>思考和分析，为什么这种模式适合这个场景，好处在哪里，代价在哪里。针对你更小一个级别的领域（比如做电商的Web，或者做社交的Web），是否存在一些设计是专门针对这类场景的</p>
<p>阅读一些设计的书籍，与你面临的现实对照。如果不符，就找高人问问为什么。比如系统上用的是MVC的某种变体，那么为啥要“变”呢？到底是当时的程序员脑子抽了，还是有个什么特别的需求。</p>
<p>进一步阅读一些设计模式的资料，分析他们出现的上下文和背景。</p>
<p>思考下你用的编程语言，那些设计思路编程语言可以帮助你快速完成；那些只能自己手工堆出来</p>
<p>再回到第1步反思，重来一遍</p>
<p>1～6过了3～5遍后，开始看其他领域和其他编程语言的设计</p>
<p>当然，为了面试，还是把23种设计模式背牢，毕竟这个世界中二的面试官有很多。</p>
<p>设计模式在实际应用中遇到问题解决问题才能很好的理解，一般网上良心写手都会强调设计模式本身的意义所在，硬套的结果是变成anti-pattern。</p>
<p>先写个几万行的代码，在把这些代码提炼和反思一遍，再看设计模式。<br> 也可以先看一遍各种大话，head first，不是为了能有啥编程上的进步，目的就是为了能看懂同事生搬硬套写的那些绕来绕去屎一样的代码为啥那么写。</p>
<p>唉 大部分人居然把这个设计模式当成一种技能负担 也是醉了。。。。。经典的设计模式学习并不是让你来深搬硬套的 而是通过这些经典的便于理解的结构来让你对软件开发进行工程化的思考 还有别这天这个书那个书的 好像他们讲的不是一个东西似的</p>
<p>想当初，自己写的东西在梦中都想着要怎么套用设计模式来把它进行重构，所谓的练功第一层，看啥是啥</p>
<p>出来工作以后，设计模式因为已经深入我心，反而不再刻意使用，虽有类似但也不再生搬硬套。</p>
<p>回顾以前看过的四人帮，head first都太晦涩生硬，继而转投大话设计模式门下。它简单生动而充满了激情，不再是一本学院派的书，适合入门也适合深入，是毕业以来看过的最为认同的关于设计模式的书。</p>
<p>废话说了那么多，以下是建议：楼主请去学校图书馆走到软件工程的那个架子上，把所有关于设计模式的书借下来，带着对比批判的心看书中关于模式的uml图，不要看文字描述。 设计模式好比工作分类，你得看他们是怎么样工作的，而不是看他们的工作描述。</p>
<p>“看书中关于模式的uml图”！！再同意不过了。真的，对于设计模式来说，UML图真的是个很重要的“工具”。讲得再多，最后真的需要一个UML来总结一个模式。记得看完《head first》的工厂模式一章后还是一脸懵逼，最后搜索了一篇博客，看到清晰的“简单工厂模式、工厂方法模式和抽象工厂”的对比UML图，瞬间清晰了……..</p>
<hr>
<p>辣集广告</p>
<p>这都信？<br> 看看这个，吹得更大。</p>
<p><a target="_blank" rel="noopener" href="http://www.zhihu.com/question/26568496">与 Hadoop 对比，如何看待 Spark 技术？ - 大数据</a><br> 王家林：Spark亚太研究院院长和<a href="https://link.zhihu.com/?target=http://baike.baidu.com/view/294385.htm">首席</a>专家，中国目前唯一移动互联网和云计算大数据集大成者。</p>
<p>《设计模式之禅》是设计模式领域公认的3本经典著作之一</p>
<p>牛逼吹得真大……<br> 从此以后俺绝不看“秦小波”的作品。</p>
<p>在IT界跳了十几年坑之后, 总结为一句: 国内作者的技术书, 基本可以不看(港澳台和译本除外). <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28558461/answer/135440798">编辑于 2019-06-30</a></p>
<hr>
<p>23种设计模式是《设计模式：可复用面向对象软件的基础》提出来的，其他书都是在此基础上进行解释和演化，很少有完全推翻它再搞一套的。不推荐读别的。</p>
<p>还有两本推荐的，不过不是设计模式相关，是架构相关的。《重构–改善既有代码的设计》和《企业应用架构模式》。</p>
<p>要学会举一反三，书当然是要看的，只是不能生搬硬套进非面向对象语言里。</p>
<p>设计模式要怎么学……感觉看书+自己写书上的例子也不怎么记得住啊……</p>
<p>先把自己的项目搞大，然后就能用设计模式了</p>
<p>《设计模式:基于C#的工程化实现及扩展》（王翔）</p>
<p>总结：我的推荐列表如下：<br> 入门（《Head First设计模式》/《设计模式》（刘伟）+《设计模式实训教程》（刘伟））→进阶（《研磨设计模式》/《设计模式之禅》）→应用（《设计模式:基于C#的工程化实现及扩展》）→理论提高（GOF《设计模式》）</p>
<p>入门的话推荐head first设计模式，熟练后还是读gof吧。</p>
<h3 id="设计模式的艺术"><a href="#设计模式的艺术" class="headerlink" title="设计模式的艺术"></a>设计模式的艺术</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/8.png"></p>
<p>《设计模式》作者还推出了其他几本书，如和此书配套的《设计模式实训教程》，不过我没读过，所以就不评价了。另外还有《C#设计模式》和《 设计模式的艺术——软件开发人员内功修炼之道 》</p>
<p>以及作者网站（<a href="https://link.zhihu.com/?target=http://blog.csdn.net/LoveLion?viewmode=contents">刘伟技术博客</a> ，</p>
<h3 id="Head-First-设计模式"><a href="#Head-First-设计模式" class="headerlink" title="Head First 设计模式"></a>Head First 设计模式</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/9.png"></p>
<p>真正的深入浅出，美中不足的是例子很西方化，小小瑕疵而已</p>
<p>我觉得这是本诙谐的技术抛砖引玉书。。。如果你有米国人的社会思维，读起来很有意思。如果你是第一次接触设计模式，这本书很有意思。但是，如果你想踏踏实实的学一些东西，这本书不行。</p>
<h3 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/10.png"></p>
<p>（GOF）：不推荐初学者看。这四人都是Phd级别，就是他们最先提出了设计模式，理论水平高，虽然薄薄一本，但是文字相对晦涩，也缺乏容易理解的例子。</p>
<h3 id="大话设计模式"><a href="#大话设计模式" class="headerlink" title="大话设计模式"></a>大话设计模式</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/11.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/12.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/13.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/14.png"></p>
<p>有些地方比较牵强，代码读着不很舒服。</p>
<p>不够深（作为入门书够了，想深看GOF去）。</p>
<h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h3><h3 id="领域驱动设计-软件核心复杂性应对之道"><a href="#领域驱动设计-软件核心复杂性应对之道" class="headerlink" title="领域驱动设计: 软件核心复杂性应对之道"></a>领域驱动设计: 软件核心复杂性应对之道</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/15.png"></p>
<p>经典之作。边看边哭，一边感动于作者的切中肯綮，一边被译者的生搬硬造气哭。不推荐读！上豆瓣看了下这三位译者翻译过的书，简直博学多才。</p>
<p>但是本书成书太老，例子也是大多数人不熟悉的会计和货运领域，所以很难搞懂应该如何把领域建模应用到实际开发中。我觉得要写好领域驱动设计这个主题，好的例子真的非常重要。</p>
<p>前面几章还是很有感觉的.后面的战略设计,太抽象了.云里雾里的非常厉害.</p>
<p>这种书就是当你还不会编程时候读不懂，会编程时候不需要读。总之就是什么时候读都不会提高自己水平。不花点时间读又不会知道不好。</p>
<p>感觉很抽象很难读懂，决定弃疗，开始读《实现领域驱动设计》</p>
<p>写的无比正确但没什么鸟用的书。你站的高是可以，但是缺乏可操作性啊</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP-IP详解-卷1：协议（原书第2版）"><a href="#TCP-IP详解-卷1：协议（原书第2版）" class="headerlink" title="TCP/IP详解 卷1：协议（原书第2版）"></a>TCP/IP详解 卷1：协议（原书第2版）</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/16.png"></p>
<p>和第一版比较 完美诠释了“冗余”的概念</p>
<p>买来时还挺高兴的，结果随手翻了一下ARP的部分，啰哩吧嗦说了一大堆也没说清，难怪会这么厚</p>
<p>感觉译者根本不懂他在翻译什么，存在很多低级错误。</p>
<p>翻译问题比较严重，瑕不掩瑜</p>
<p>妙啊 翻译是真的不行，可以感受到译者敷衍了事的心态，能不能像罗老师一样有点工匠精神（手动狗头</p>
<p>第一版：</p>
<p>此书我中英文来回翻着阅读，对比着中英文，我对译文的作者的从起初的鄙夷到气愤到最后的没脾气，中文版的最大收获便是让我恍惚觉得，如果给我同样的时间，我翻译的同样的一部分，未必就比原译者差，或许还好上那么几分。<br> 书籍的翻译达不到信达雅也就不怪你们了，咱们都是工科毕业生，只追求准确也总可以了吧。<br> 可是书中大把的错误，有的原书5秒翻译成了5分钟，这么低级的错误都犯了，还印了那么多版，印了12年，算你们狠；有的语法的定状补都分不清，原文形容词你用作副词，有的常用的短语allow for你都翻译不出来，有的专有词汇翻译得不如直接给英文单词，各种各样的错误，书籍简直就是在误导读者。<br> 翻译在国内是个普遍的存在的很大的问题，我见过有将微软wrting solid code中的function interface翻译成函数界面，并且整篇都是。我不知道翻译的是怎样的人，不清楚出版界的出版流程，但这种二三流的翻译在现阶段是个普遍的问题。<br> 书籍是经典，讲的不仅仅是枯燥的理论知识，其中丰富的例子实践，能让你观察到TCP底层的每一个操作，美中不足的是有些内容显得已经过时。<br> 对于英文还是比较扎实的同学，我强烈推荐你们读原版，或者两本一起阅读，再不然把中文版当做一本google词典也是不错的选择。</p>
<p> 典型的笑话翻译“round-robin”翻译成“周围的知更鸟”。 本来N年前看过就觉得很差，现在还是忍不住告诉读者不要买这本中译版，看原著吧，原著的英文写的很通俗易懂，读起来也很快的。</p>
<hr>
<p> 新版基本上除了封面和第一版一样之外，内容上基本上都被重写了，包括写作风格和方式。<br> 缺点：1、章节的编排顺序匪夷所思。DHCP,firewall,NAT被放在了TCP,UDP章节之前。话说你连port都不知道是什么东西的时候，作者你指望读者能搞明白NAT？搞明白如何配置firewall？？你说DHCP是作为UDP的payload，可是UDP又是什么东西？</p>
<p> 2、详略不当。wireless/ppp/stp/pppoe/tunneling都要讲,但是没一个讲明白的，这些东西本来也就不是作者安排的几十页能说清楚的。你何苦啊？要知道把这些东西说的差不多的TCP/IP Guide可是用了1500+页啊~~你还少了500+页呢~~~ end to end argument和fate sharing这两个和Internet体系相关的重要设计理念其实应该多讲一些，结果只用了一页。讲STUN的时候，其实我们最希望知道如何利用STUN来进行NAT穿越，可惜作者并没有讲。当然了，如果你那这本书来学习TCP/IP的话，不指望你能看明白这一章。因为这章本该是放在TCP之后再讲的。</p>
<p> 3、虽说也采用了抓包来解释协议的实际运作过程，可是实际上并没有太多的使用这种方式，很多地方颇有读RFC的感觉。</p>
<p> 4、相比第一版颇有价值的课后题，新版没有了…</p>
<p>优点：补充了很多新内容；每章后的reference挺有价值；TCP部分写的很是不错（亮点！）</p>
<p> PS. (1) DMZ这个缩写没有在正文中给出全称；<br> (2) 讲wireless的时候，提到了ESSID，在CWNA Certified Wireless Network Administrator Official Study Guide这本书里作者都已经专门澄清过：有SSID，BSSID，但是就是没有所谓的ESSID这个概念。<br> (3) datagram和packet这两个术语的关系一直没讲。在第一版中，在第一章就特别对此进行了说明。（RFC1122上亦有）</p>
<p> 建议：通常一本书出了新版之后就意味着老版可以扔掉了，不过这次是个例外。第一版你还得留在手边，第二版可以作为补充。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image017.png"></p>
<h3 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image018.png"></p>
<p>最少必要知识。科普版。快速让人对Web领域的很多概念有个清晰的了解。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统–精髓与设计原理"><a href="#操作系统–精髓与设计原理" class="headerlink" title="操作系统–精髓与设计原理"></a>操作系统–精髓与设计原理</h3><p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86.png"></p>
<p>换成人民邮电出版社了，译者也换了</p>
<h3 id="操作系统导论：-Operating-Systems-Three-Easy-Pieces"><a href="#操作系统导论：-Operating-Systems-Three-Easy-Pieces" class="headerlink" title="操作系统导论： Operating Systems: Three Easy Pieces"></a>操作系统导论： Operating Systems: Three Easy Pieces</h3><p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA.png"></p>
<p>英文版书籍：<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/%EF%BC%88%E5%BC%80%E6%BA%90%EF%BC%89">https://pages.cs.wisc.edu/~remzi/OSTEP/（开源）</a></p>
<p>tree pieces：虚拟化＋并发＋持久性，三个角度展开</p>
<p>这本书优点是语言非常简单易懂，所以直接读英文版也无障碍。 缺点是细节不够，对于有些概念讲解不够深入，容易造成误解。 所以这本书定位是第一本入门的操作系统书籍，需要结合其他书参考。另外，《operating system principles and practice》这本书也是极其不错的，但是可惜的是国内连英文版都没引进。</p>
<p>有时候本来是很重要的东西却误以为是补充内容就跳过了。</p>
<p>MIT6.828的手册根本不过瘾，看这本解答了好多疑惑！顺便推荐《x86从实模式到保护模式》，配合MIT6.828的实验，简直不要太舒服！</p>
<p>最后的分布式文件系统和虚拟机的讨论意犹未尽啊。这本书值6颗星，扣2颗星给翻译和排版，</p>
<p>基本也是按照“发现问题，解决问题”的思路来写，属于 #希望早十年读这本书# 这一类。</p>
<h3 id="现代操作系统（原书第4版）"><a href="#现代操作系统（原书第4版）" class="headerlink" title="现代操作系统（原书第4版）"></a>现代操作系统（原书第4版）</h3><p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC4%E7%89%88%EF%BC%89.png"></p>
<p>适合专业地学习，对于入门来说还是精简的教材学得更快。不是一本实践的书。科学文摘，每个知识都点到为止，不做解释和深入。</p>
<p>翻译差</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>《C Primer Plus》(第5版）中文版 买新版</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h3 id="C-Primer"><a href="#C-Primer" class="headerlink" title="C++ Primer"></a>C++ Primer</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image019.png"></p>
<p>本书适合C++新手，而不是编程新手看</p>
<p>当字典翻阅</p>
<p>在实际操作时把这本书作为手册，遇到有疑问的地方，或者不确定的地方，再仔细阅读。读这本书，比在网上胡乱搜索要好得多。书中的内容都是详细、准确无疑的，许多地方都有例子。书后有索引，可以根据名词找到对应的页数。</p>
<p>奉劝读此书的人一定要去读英文原版，因为翻译者是个极其不严谨的人！此书280页“IO库定义了一个与机器无关的iostate类型”，而原版是“The IO library deﬁnes a machine-dependent integral type”</p>
<p>一看翻译和审校的阵容就知道这书值得拥有有<strong>陈硕</strong>大佬</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image020.png"></p>
<h3 id="C-Primer-Plus"><a href="#C-Primer-Plus" class="headerlink" title="C Primer Plus"></a>C Primer Plus</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image021.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image022.png"></p>
<p>千万别买</p>
<h3 id="《Essential-C-》"><a href="#《Essential-C-》" class="headerlink" title="《Essential C++》"></a>《Essential C++》</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image023.png"></p>
<p>如果觉得c++ primer太厚，可以读读作者写的这一本</p>
<p>适合老手复习语法</p>
<h3 id="C-标准库-第2版"><a href="#C-标准库-第2版" class="headerlink" title="C++标准库(第2版)"></a>C++标准库(第2版)</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image024.png"></p>
<p>快速的看完了, 觉得买的还是比较值得. 不过读过一遍以后基本就不会再翻了. 主要是 DASH 太好用了</p>
<p>就是字典。</p>
<p>分类很科学，讲的很细，有代码实例，唯一美中不足就是type_trait相关的东西一点都没讲，不知道为什么</p>
<p>终于更新了C++11标准的第二版了啊 对于标准库的各种用法、注意事项及其原因介绍详尽 美中不足的是allocator的介绍还是太少了 不过也是因为这本书只是从使用者的角度来讲的吧</p>
<p>字典式图书，层次初/中级，只适合用来查询，不推荐逐章阅读。</p>
<p>STL的设计思想（通过迭代器将数据结构和算法分离，获得通用性的程序组件）是此书的精华。。其余的部分诸如复数complex，valarray，bitset，strings，国际化等等，了解一下即可，没有必要深究。还有令人纠结的auto_ptr，本身就是一个设计失败的产物，当一个组件给你提供了3条功能却告诉你为了使用这3条功能你需要遵守10大戒律的时候，这个组件本身的设计没准就是有问题的。很不幸，在我看来，auto_ptr就是这样的组件，使用它会带上很大的心智负担（C++的很多特性都是如此，看上去很强大很花哨，但深究起来发展这里面的陷阱很多，会给使用者带来很大的心智负担）。</p>
<p>去除以上两部分，此书最有价值的东西就在300页左右，也就是第5-10章的内容，细说起来，就是STL，容器、算法、迭代器、仿函数。</p>
<p> 我的数学基础并不能参透STL这些背后的数学思想，不过仅有的一些lisp和scheme的知识，倒让我在STL中的某些组件里面，找到了一些似曾相识的东西。</p>
<p> 比如像functor（仿函数），我觉得仿函数的本质在于将函数的地位提升到和C++ class同样的一等公民的位置。在scheme中，函数（操作）和数据一样，都可以作为一等公民，可以当做参数传递、返回。而在C++中，数据才是一等公民，C++ class的各种机制（构造函数、析构函数、运算符重载等），无非也就是让用户自定义的class拥有和built-in的类型一样的使用接口和特性（比如像std::complex和int）。但函数本身在C++中并不能通过很轻易的方式成为一等公民。要想像普通数据一样传递函数，需要用到函数指针。而functor的存在，就是为了通过重载operator()，来实现传递“函数（操作）”的目的。至于优点和好处，此书上已经说的很清楚了。</p>
<p> 再比如像transform()、for_each()、accumulate()算法，如果你读过SICP前两章，你就会发现这其实和lisp/scheme里面的map/reduce函数有异曲同工之妙。MapReduce？没错，就是那个MapReduce，google的那个MapReduce。</p>
<p> 语言是会影响人的思维的。所以我并不赞同“语言和工具不重要”的这种论调，没错，语言是相通的，C++可以做到的事情，汇编一样可以，本质上大家都是Turing-Complete的。但是Turing-Complete并不意味着相同的表现形式和使用难度，多学几种语言，多了解几种思想，不盲目崇拜，跳出语言的框架去学习语言，是很重要的。</p>
<p>扯远了，回头说说阅读此书的基础和后续吧。首先需要对C++有比较好的了解，如果连const、reference都搞不清楚，还是不要读此书了。其次最好对模板技术有一些了解，最好能看些”C++ Template: The Complete Guide”，了解下type traits这类技术。</p>
<p>读完此书后，找个机会动手实现下STL的各种container和一些基础算法，Mark A.Weiss有一本老书”Data Structures and Problem Solving Using C++”，包含了很多STL的实现代码和STL的应用，很不错，可惜现在很难搞到。有机会再去读读侯先生的”STL源码剖析”。当然，更高阶的，什么c++ template metaprogramming，我就不继续了。</p>
<p>“STL的核心设计思想是数据结构和算法的分离，这个从某种意义上来讲，是和OOP的思想背道而驰的。所以在STL中只用到了Object-based的东西，却没有用到Object-oriented，STL没有用到继承。STL之父Alexander Stepanov也并不是100%赞同OOP的” 这点上，不是很赞同诶。 1) effective c++ 专门有两三章讲分离是为了更好的OOP。OOP有三个基本点：encapsulation（in which case the state is kept separate。在 stl 里面，iterator，traits不就是体现了这一点么？）；2）inheritance（stl源码有大量的继承）；3）polymorphism； 2）我觉得有挺多设计思想的，把说烂了的OOP用得相当有意思，粒度把握得很值得思考； 3）STL 宏真是一大亮点。</p>
<p>私以为不该从C++入手去探求其思想，而应该从更正常的语言那里了解了这些思想再回头看C++如何带着镣铐跳舞。从实际应用的角度权衡它有时可以是最佳选择，但想从这里入手学习思想什么的几乎总是事倍功半吧。 functor不过是没有lambda时的难用的替代品罢了，起个高端的名字也不能把缺陷变成feature。C++对map、reduce这样的高阶函数本来支持有限，在lambda引入前更是半残；想了解这类思想的话从C#的LINQ入手都更合适。至于迭代器（和更一般情况下泛型）所带来的可扩展性，如果把模板简化地看做编译期的鸭子类型的话，这不过是面向接口编程的结果，从动态语言就能找到更友好的例子，比如Ruby的Mixin。又比如模板元的图灵完备性来源于其递归结构（和对整数操作的支持），如果想了解怎么在没有循环结构和副作用的情况下实现各种功能，去看看正常点的函数式语言就好了，何必把生命浪费在和c++编译器的斗争上。当然要是C++有完善一点的宏支持，或者它自己本身完善一些，谁会这么蛋疼。</p>
<p>一周不到，你看清楚了吗？就在这儿大放厥词</p>
<p>一边刷Leetcode，一边学习STL，效率很高。</p>
<p>666，auto_ptr在 c++11里面被另外三个智能指针给取代了，你知道么，貌似你写这篇文章的时候c++11已经出来了吧</p>
<p><a target="_blank" rel="noopener" href="http://www.wutianqi.com/blog/2131.html">《C++标准程序库》读后感</a></p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="精通正则表达式"><a href="#精通正则表达式" class="headerlink" title="精通正则表达式"></a>精通正则表达式</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image025.png"></p>
<h3 id="正则表达式必知必会"><a href="#正则表达式必知必会" class="headerlink" title="正则表达式必知必会"></a>正则表达式必知必会</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image026.png"></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image027.png"></p>
<p>实际上像 redis in action和 redis设计与实现 这样的书是很好读的，好理解也好记。看完一遍把书合上，过一阵再对着目录想，记得不清的再看就好。总之，针对特定问题，提出解决方案的书，更容易读些。</p>
<p>本书介绍的很多技巧是基于把redis当成数据落地的db来用，据我所知很少有人会这么干，也许是我孤陋寡闻吧。对我而言，redis首先是缓存，其次是局部业务性能优化的备用方案。将redis当成纯db来用太过于极端了。不过介绍很多技巧也是大开眼界。</p>
<p>把redis当数据库用，就问你怕不怕，我反正是怕的，当数据库用太反直觉了，编写维护都很费事，容易出错，生产使用风险太大。说是redis实战，无需先验知识，但是初学者看这本书肯定很吃力，python的一些高级语法加上简单晦涩的描述，后半部分缺乏图表及示例，对于读者理解会造成很大的困惑，这本书4星其实也有点多，不太推荐，大家可以找更好的关于redis的书籍阅读</p>
<p>本书主要话题是讲述以Redis为底层存储，如何构建实现方案来支撑不同的应用场景。学习这些案例可以扩展思路，学习使用Redis的能力来搭建出功能强大的小服务。</p>
<p>一本实用的Redis入门书籍。可以考虑入手一本，拓宽Redis的应用思维。</p>
<h3 id="Redis设计与实现"><a href="#Redis设计与实现" class="headerlink" title="Redis设计与实现"></a>Redis设计与实现</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image028.png"></p>
<p>对于没时间读源码的同学理解redis的机制有很大的帮助</p>
<p>，要了解Redis内部原理，此书必备，</p>
<p>对于有心一窥redis实现原理的读者来说，本书展露了足够丰富的内容和细节，却不至于让冗长的实现代码吓跑读者——伪代码的意义在此。下一步是真正读源码了。</p>
<p>读源码类书籍，最重要的是要看到作者的想法而不是源码本身，否则，直接读源码就好了，这本还不错</p>
<p>不够深入。后面的章节有点水</p>
<p>对于运维的同学第8-21章一定要看。</p>
<p>比redis的docs好 除了cluster以外基本都介绍了 要是再有些横向对比就好了</p>
<p>细节还是要看 redis.io 和源码。</p>
<p>适合想要了解源码的同学作为入门书看</p>
<p>算是进阶入门还行 缺少最新的HyperLogLog Geo 淘汰算法 pipeline介绍</p>
<p>建议看下序言 阅读本书指南 </p>
<p>第一部分 必须 第二部分 可以 不用那么深究 </p>
<p>第三部分 可选 </p>
<p>第四部分的话 事务 发布于订阅 排序 可以看看 </p>
<p>有一点伊文思 sort 命令后续的多个get 为什么是顺序敏感的呢 </p>
<p>get认为是 条件过滤器 ,需要同时满足 应该 不介意get之间的顺序阿 </p>
<h3 id="Redis开发与运维"><a href="#Redis开发与运维" class="headerlink" title="Redis开发与运维"></a>Redis开发与运维</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image029.png"></p>
<p>除了集群部分都很好，集群部分redis cluster和那个cache cloud真的不行，还是要看codis和twitter的那个</p>
<p>论谈操作使用还是讲解实现原理都结合实际场景，很接地气。写作语言也平实清楚，堪称国内技术书的模范</p>
<p>实战出真经，有场景支撑的教材。</p>
<p>大概是目前为止看到最好的 Redis 综合内容的书：比 redis in action 更接地气（适合国内的使用场景）</p>
<p>这本书更侧重于实践，但内容深入浅出，非常适合与《Redis设计与实现》一起食用。</p>
<h2 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h2><h3 id="代码大全（第2版）"><a href="#代码大全（第2版）" class="headerlink" title="代码大全（第2版）"></a>代码大全（第2版）</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image030.png"></p>
<p>所以我想说说这本书读的时机。</p>
<p> 入行1年，至少完整的跟过一两个商业项目的程序员应该是初读这本书的时机。然后在自己开始思考代码结构，设计，脱离代码工人层次的时候可以考虑去读第二遍。</p>
<p>纸上得来终觉浅, 绝知此事要躬行。</p>
<p>每一章后面都有这一章的要点,略读这些要点中我们就可以了解到我们已经掌握了哪些知识,哪些知识还没有掌握，阅读，重读时就有重点了。</p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/review/1075004/">https://book.douban.com/review/1075004/</a></p>
<p>Code Complete大概就是完成了相当的测试后，发布以前，认为程序的代码不应该再被修改，于是Code Complete。</p>
<p>当你失恋过之后，你便理解了所有情歌的意义；当你做过一个不甚理想的框架与设计之后，你便明白了这本书的价值。</p>
<p>其实看开源社区的优秀代码才是学习软件构建的和架构的手段..</p>
<p>构建的核心就是管理复杂度，要把主要精力集中于构建活动，采用自上而下的思考，自下而上的执行，这样才能提高工作效率。</p>
<p>前面一小半有点太过基础，适合初学者；中间关于测试，重构，调试，调优的几章把重点都点到了，但是还是需要去看相关的深入的书；最后几张代码风格和程序员性格什么的有点凑字数占篇幅的嫌疑……书里有一些箴言和金句，但是必须自己<strong>在实际工作中有体会才能共鸣</strong>，不可能出现“本来啥都不懂，看完那些指导就一下子明白了”。</p>
<p>前两百页是工程学的基础知识、excel其实就是个简便的数据库兼编程工具，在当前计算机运算能力过剩的情况下，这个软件用处非常大，可以简化大多数办公室的程序化劳动，提升你临时解决批量问题的能力。你用excel能随意搭建逻辑链，把两个不同领域的相关问题结合到一起处理的时候-</p>
<p>那个表驱动法一定要看…事这本书里印象最深的一处</p>
<p>先看Kernighan的程序设计实践再看此书效果更佳</p>
<p>还有人提到《人月神话》，我想再加上《人件》、《你的灯亮着吗》，这四本书籍对我影响至深。</p>
<p>老实说，《代码》虽然成书晚，讲的具体细微，其质量并不如《人月》。很多观点也值得商榷。</p>
<p>比如说，《代码》虽然列举，但是贬低把软件开发视为 organic grow 的过程。反而把建筑的比喻作为讨论的基础。我并不同意。<a href="https://link.zhihu.com/?target=https://techsingular.org/2011/09/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%96%9C%E6%AC%A2%E7%94%A8%E5%BB%BA%E7%AD%91%E6%AF%94%E5%96%BB%E8%BD%AF%E4%BB%B6/">为什么我不喜欢用建筑比喻软件</a> 。软件的构建是团队知识的固化过程，而建筑并没有「知识固化」这个过程。</p>
<p>而且，用建筑来比喻软件，往往是搞错了软件的设计和生产。曾经有很长一段时间，人们认为软件的高层设计是「设计」，而 coding 是「生产」软件。错！Coding 就是 design —— <a href="https://link.zhihu.com/?target=http://www.developerdotstar.com/mag/articles/reeves_design_main.html">Code as Design: Three Essays by Jack W. Reeves</a>。所以，软件构建的大部分时间，相当于建筑的蓝图绘制阶段。当你用建筑的蓝图绘制来比喻软件的 planning，本身就是会错了意。软件的 planning 相当于建筑里开始绘制蓝图之前的非正式构思。</p>
<p>另外，为了 Unit Test 引入的各种 trick，我也不能认同。<a href="https://link.zhihu.com/?target=https://techsingular.org/2012/09/24/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E7%BB%AD%EF%BC%89/">关于单元测试（续）</a></p>
<p>我现在也倾向于用集成测试例代替单元测试了</p>
<p>开始编程的时候，读的不知所云；</p>
<p>敲了一年代码之后，读的如饮甘泉，醍醐灌顶，如获独孤九剑一般；</p>
<p>敲了五年代码之后，读的吹毛求疵，鸡蛋里面挑骨头说，这里过时了，这里不合理……</p>
<p>现在敲了十年代码了，再次去翻，不觉叹息，方知经典永不褪色。</p>
<p>说的太好了，入行1年，一直放在手边，写代码，随时翻阅；入行五年，此书给我垫了显示器，觉得里面道理我都懂；入行十多年，此书又给我擦的干干净净，放在手边，时时给后辈推荐。最近买了本英文的，又对作者敬意加深…</p>
<p>也让你从模块、组件、架构等角度理解你的代码，它真正提醒我们，世界是面向对象的，我们也可以面向对象，冗余不代表都是坏的，而完美也不代表就真的完美。</p>
<p>当然做了这么多年开发，最深的体会还是软件是为人所用的，创造价值甚至比它完不完美还要重要，傻子才一味追求工匠精神，天才都是在让创造的事物实现最大价值的情况下一步步完善它，</p>
<p>代码大全教会你如何变成一个计算机科学家式的好程序猿或工程狮，而创新却非每个人都能有，唯有天才引领我们的时代。<br> 上士闻道，勤而行之，中士闻道，若存若亡，下士闻道则笑之，不笑不足以为道。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image031.png"></p>
<p>印象比较深的是表驱动法这块，记得在另外一本书中看到过相似的说法，聪明的数据结构搭配愚蠢的代码远比反过来要好得多。另外就是关于防御式编程的方式往往会让代码过于冗余，有些时候反而应该避免防御式的思想</p>
<p>这本书和人月神话类似，不过现在肯定也可以说是过时了。两本书按照现在的眼光看来都没有能够真正理解现代软件工程的关键，<strong>非要读这方面的书应该是敏捷系的东西更符合当前实际。</strong>具体为何这本书细节过时我就不想展开说了，比较简单的例子是现在讨论匈牙利命名约定是很扯淡的事情，设计模式这些interface hack汇总在任何能够把函数作为数据的语言里都没有存在必要了。</p>
<p><strong>The Pragmatic Programmer****吧，从这本看起应该还是不错的</strong></p>
<p><strong>“<strong><strong>不要用战术上的勤奋掩盖战略上的懒惰</strong></strong>“</strong>，很多时候，受限于开发经验，对于项目，直接上手完成，缺少对代码结构的构思。当需要维护时，付出巨大时间成本去修改。这其实是一种逃避，只顾着编写，却忽略了更为重要的对代码设计的思考。</p>
<p>《代码大全》和《代码整洁之道》有什么区别？更应该优先读哪个？</p>
<p>如果是学生或刚工作的话建议先读《代码整洁之道》，再读《代码大全2》。</p>
<p>《**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/4199741/">代码整洁之道</a>**》工作后接触的项目大而且杂和乱，感觉代码不应该是这个样子的，遂去图书馆，看到了这本书，正是我想要的。 *<strong>让我明白了代码应该写成什么样</strong>；</p>
<p>《**<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/2248759/">修改代码的艺术</a><strong>》问题同上，前者让我明白了代码应该写成什么样，后者</strong>让我知道了面对混乱的代码，应该如何去做**；</p>
<p>1、《<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/1229923/">重构 : 改善既有代码的设计</a>》Java语言版，看过“代码整洁之道”和“修改代码的艺术”，读完这本书感觉一般，不知道先读这本书会不会感觉不一样，豆瓣评价很高</p>
<p>2、《<a href="https://link.zhihu.com/?target=https://book.douban.com/subject/27605355"><strong>阿里巴巴<strong><strong>Java</strong></strong>开发手册</strong></a>》/《<a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000002761014">Google Java Style</a>》、<a href="https://link.zhihu.com/?target=https://www.sonarqube.org/"><strong>SonarQuber</strong></a>（代码质量检测工具）、IDE代码质量检测插件SonarLint、SpotBugs、**<a href="https://link.zhihu.com/?target=https://github.com/alibaba/p3c">阿里P3C</a>**</p>
<p>，前面几章有些抽象，从第六章开始比较具体的介绍编码时应该养成的好的习惯。</p>
<p>精华是6-13章，差不多就是第二第三部分，真正的精华，则是特别透彻的解析了模块化编程的思想，以及该如何去做。第9章的用伪代码去编写过程，实在是太精彩了。能够让你不断思考细化你该如何去组织你的代码结构。梳理编程思路。</p>
<p>总结一下，其实让我记忆深刻的主要是</p>
<p> 首先，软件构建的核心就是<strong>管理复杂度</strong>。虽然书中有不少的篇幅来讨论变量、语句等等这些编程的基本要素，还包括代码改善和调整的策略和方法，可谓不无巨细。不过深入理解一下，这些内容都是围绕着上面这句话展开的，也就是软件构建的核心就是管理复杂度。而这一目标产生的根源就在于人脑智力同软件项目复杂程度之间的矛盾。书中常常会提到几个数字，差不多在6、7左右变化，因为这是人脑智力管理的极限，多了，就管不过来了，呵呵。所以，书中会有一些结论性的建议。比如构建可工作的类，内部成员应该控制在7(+-)2，也就是5个或者9个左右，如果都是Native Type的话，9个成员变量能管的过来，如果都是对象成员的话，5个也能保证你的头脑始终清晰。还有，比如程序中的嵌套结构，类似于If，循环啊什么的，要保持嵌套层次不能多于6层，而据实际调查，一般3层以上的嵌套就会使程序员非常的困惑和抓狂了；还有比如子程序的参数个数尽量保持在7个以下，要不然也记不住，别说7个了，没有现代IDE的帮助，我连4个以上的参数我都记不住，呵呵。</p>
<p> 我想满足这些指标并不是很难的事情，而这些东西也给出了对于代码进行改善时候可以依据的标准。不过想要管理这种复杂度，从作者的书中总结一下，具体可能是以下几点：第一，分割，既然大脑管不过来，那就把系统进行分割，也就是从设计角度上抽象出若干部分，每次让大脑focus在一个部分上，这点我是有深刻体会，虽然我现在完全自己做的东西超不过15000行，不过也不能妄想自己把所有的部分都记住，如果抽象的不好的话，我就特别头疼，每天在代码中翻来翻去的，效率非常低；第二，清晰理解，其实这点跟上面一点是差不多的，只有清晰理解了抽象的含义，才能做好每个封装每个接口，这样在关注别的抽象部分的时候，其他部分需要记住和管理的更清晰也更简洁，因为不需要关注其他部分是如何实现的，只要按照接口和抽象来做就好了；第三，清晰表达，在程序中应该清晰表达逻辑和抽象含义，也就是增加程序的可读性，唉，这点太重要了，书上也围绕着这个不断的论述，上面提到那些事无巨细的部分反复的说着这一点，甚至连命名都有专门的一章来讨论。</p>
<p> 最后，本书对设计模式，重构以及软件工程方面也有所涉猎，但是只可当作提纲，概要。对这些东西，要读的书就太多了。比如设计模式可以去读深入浅出设计模式和Gof的那本，重构显然应该去看福勒的重构。</p>
<h3 id="程序员的自我修养-链接、装载与库"><a href="#程序员的自我修养-链接、装载与库" class="headerlink" title="程序员的自我修养 链接、装载与库"></a>程序员的自我修养 链接、装载与库</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image032.png"></p>
<p>为了能够读懂这本书，需要先掌握以下内容：<br> \1. CPU体系结构<br> \2. 计算机体系结构<br> \3. 汇编语言<br> \4. 编译原理<br> \5. 操作系统<br> \6. C/C++语言<br> \7. 编译器是如何产生处理代码的（建议阅读《Delphi源码分析》）</p>
<p>如果你已经学习或接触了C，汇编，计算机结构，但还是没办法把三者的关系理的很顺很清或者对应起来<br> 那么深入研读一下这本书绝对是对你的一大帮助</p>
<p>这本书一步步的剖析了一个程序的前世今生，从代码的编译，到链接，到运行时虚拟空间物理空间的映射，到内存的分配，无不一一展开，还原一个程序本来的面目。</p>
<p>就像此书中引用的一句无法考证其作者的话说的那样：任何计算机的问题都可以通过增加一个层来解决。</p>
<p>随着各种问题的解决，计算机的层增加的越来越多，</p>
<p>但是这本书隐约给了我们一个回答，总有些东西是不会变的，</p>
<p>好吧，从内容上，这本书一定值得你一翻，就算你不通读，把第二、第三部分仔细读读一定会很有收获，如果你对系统的机理感兴趣，特别是，如果你是linux C/C++程序员，我如是推荐。</p>
<h3 id="代码整洁之道-程序员的职业素养"><a href="#代码整洁之道-程序员的职业素养" class="headerlink" title="代码整洁之道:程序员的职业素养"></a>代码整洁之道:程序员的职业素养</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image033.png"></p>
<p>值得一看，主要还是软件工程的一套，但不乏点睛之笔，适合粗读。但是书名翻译太强行，其实跟代码整洁没啥关系，主要讲的是如果成为一个专业负责的程序员。</p>
<p>不认同书中的大多数观点，这本书显得过时了。猜测作者是出身于传统软件行业的老程序员？对于员工的要求过于苛刻，看问题的角度像是老板而不是程序员。关于测试，盲目追求覆盖率甚至为了测试改变程序应有的结构，我觉得是不可接受的。文中很多观点浮于表面，比如要求代码要经常改，我同意，但本质上应该保持简洁的同时应变复杂的需求。只有简单的东西才是可以被依赖的。总之，这本书一行代码都没，感觉在瞎扯。</p>
<p>书中的内容都很棒，对于一个程序员的要求也算是正常要求，但是译者在某些用词上简直没眼看，如果不是机翻那就是作者缺乏一些项目管理领域和个人时间管理领域的知识，甚至让我对其专业能力产生了怀疑。 比如将Affinity Estimation翻译成关联预估，这是非常基础的项目管理用词。再比如4.2流态区是什么东西？从下面的内容来看应该是“心流”，这也是常见的时间管理用词。 还有那个“1024字的磁鼓式内存”已经让我彻底怀疑作者的专业性了，先不说这里到底是byte还是bit，作为译者真的有好好读这个翻译的结果么？</p>
<p>提供了与他人合作的时很多问题的解决方案，专业的素养，专业的沟通，专业的估计，专业的抗压也即说“不”。</p>
<p>作者以自己的经历讲述程序员这个职业应该有的素养：tdd 重构 估算 。</p>
<h3 id="《重构：改善既有代码的设计》"><a href="#《重构：改善既有代码的设计》" class="headerlink" title="《重构：改善既有代码的设计》"></a>《重构：改善既有代码的设计》</h3><p>重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，</p>
<p>《设计模式》</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image034.png"></p>
<p>7.《编译原理》</p>
<p>《编译原理》全面、深入地探讨了编译器设计方面的重要主题，包括词法分析、语法分析、语法制导定义和语法制导翻译、运行时刻环境、目标代码生成、代码优化技术、并行性检测以及过程间分析技术，并在相关章节中给出大量的实例。与上一版相比，《编译原理》进行了全面修订，涵盖了编译器开发方面最新进展。每章中都提供了大量的实例及参考文献。</p>
<p>9.《修改代码的艺术》</p>
<p>我们都知道，即使是最训练有素的开发团队，也不能保证始终编写出清晰高效的代码。如果不积极地修改、挽救，随着时间流逝，所有软件都会不可避免地渐渐变得复杂、难以理解，最终腐化、变质。</p>
<p>本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作，而且从涵盖面和深度上都超过了前两部经典。书中不仅讲述面向对象语言（Java、C#和C++）代码，也有专章讨论C这样的过程式语言。作者将理解、测试和修改代码的原理、技术和最新工具（自动化重构工具、单元测试框架、仿对象、集成测试框架等），与解依赖技术和大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。</p>
<p>0.《Patterns ofEnterprise Application Architecture / 企业应用架构模式》</p>
<p>《企业应用架构模式》作者是当今面向对象软件开发的权威，他在一组专家级合作者的帮助下，将40多种经常出现的解决方案转化成模式，最终写成这本能够应用于任何一种企业应用平台的、关于解决方案的、不可或缺的手册。《企业应用架构模式》获得了2003年度美国软件开发杂志图书类的生产效率奖和读者选择奖。《企业应用架构模式》分为两大部分。第一部分是关于如何开发企业应用的简单介绍。第二部分是《企业应用架构模式》的主体，是关于模式的详细参考手册，每个模式都给出使用方法和实现信息，并配以详细的Java代码或C#代码示例。此外，整《企业应用架构模式》中还用了大量UML图来进一步阐明有关概念。</p>
<p>《企业应用架构模式》是为致力于设计和构建企业应用的软件架构师、设计人员和编程人员而写的，同时也可作为高等院校计算机专业及软件学院相关课程的参考教材。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image035.png"></p>
<p>书中的代码有些写得不太过关</p>
<p>题目都很好，讲解清晰，内容五星。小缺点是代码中几乎没注释；没找到勘误；最令人不解的是：这么经典的一本书，已经是第二版，以及已经是第N次印刷了，居然还留有很多笔误，这就是作者态度不够诚恳了。</p>
<p>题型很多，扫盲必备</p>
<h3 id="算法导论CLRS"><a href="#算法导论CLRS" class="headerlink" title="算法导论CLRS"></a>算法导论CLRS</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image036.png"></p>
<p>翻译一直都是问题 ＝ ＝ 还是看英文原版的好</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image037.png"></p>
<p>需要较强的数学基础与数学思路, 不是非常适合工程研发人员学习. 尤其对于某些比较复杂的结构, 如红黑树、B树等, 展开解释的太少从而过于生涩, 需要额外的学习资料</p>
<p>本书的翻译问题主要出现在殷建平负责的1~3章了，很多部分是<strong>机翻</strong>的，是的，<strong>机翻</strong>。</p>
<p>比如红黑树，我看其他的资料完全无法理解。但是看了算法导论第13章，配合习题食用，恍然大悟，讲解的太透彻了！</p>
<p>个人还是推荐通过网课加看书的形式来学习算法。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image038.png"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image039.png"></p>
<p>这本应该算是最简单的算法书了，</p>
<h3 id="算法设计手册"><a href="#算法设计手册" class="headerlink" title="算法设计手册"></a>算法设计手册</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image040.png"></p>
<p>这是一本中级算法书，之前没有编程基础看此书很可能会觉得没讲明白。 特点正如标题所示是手册：简短的语言总结和比较了种种算法与数据结构。无怪Steve Yegge推荐给程序员面试前复习算法用。学习算法不建议用这本，而应该选择更详细全面的CLRS或者Kleinberg&amp;Tardos</p>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="程序员面试宝典"><a href="#程序员面试宝典" class="headerlink" title="程序员面试宝典"></a>程序员面试宝典</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image041.png"></p>
<p>有些问题显示出作者的视野只局限在微软平台下，有些答案在非微软平台下是不正确的，建议批判地看</p>
<p>书还行，不过错误太多，误人子弟，</p>
<p>我只能说勘误非常多，作为一本快速准备型的面试书只能说凑合，</p>
<p>对于c/c++的知识点覆盖还算全面，有些例子事实证明的确很经典，当然莫名其妙的错误也有不少。这本书可能不会真的帮助解决什么实质性问题，但是补补边角料，并且了解自己还有哪些方面仍需补强还是很有帮助的</p>
<p>给个两星吧，作者收集这么多题目也不容易，不过解释真的是乱七八糟的啊，如果牵强附会的给出解释，还不如不给，</p>
<p>就题目而言认真读完还是不错的，但是解答部分估计是网上照搬，经常有不知所云的情况出现；</p>
<h3 id="程序员面试金典"><a href="#程序员面试金典" class="headerlink" title="程序员面试金典"></a>程序员面试金典</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image042.png"></p>
<p>书中最核心的还是面试中的题目了。</p>
<p>书中有一道习题使用了后缀树。后缀树这个特殊的结构在《算法导论》等众多书中都没有出现，可以在网上找到一些计算生物学的课件。很多匹配字符串相关的问题都可以用后缀树或者广义后缀树给出一个线性解法。但注意的是这个数据结构所占用的空间也是很大的。虽然一些情况下可以优化到线性，但这种优化在一些具体的问题中会改变问题的语意，因此不是任何时候都可以适用的。对后缀树和广义后缀树感兴趣可以参考<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1765938/">http://book.douban.com/subject/1765938/</a>，网上也可以找到一些相关的课件</p>
<p>书中有”连续子序列最大和值“和”最长递增子序列“这样的题目。但是没有包含”连续子序列最大积值“这样的题目，并且”最长递增子序列“给出的解答不是最优的，这两个题目大家可以额外思考一下，面试中也很常见。</p>
<p>另外，面试过程中也会遇到很多与系统相关的知识性的题目，如流水线、虚拟内存、进程线程、地址空间结构、异常处理、并发编程等等，这些内容可以参考《深入理解计算机系统》<a target="_blank" rel="noopener" href="https://book.douban.com/subject/5407246/">http://book.douban.com/subject/5407246/</a>。</p>
<p>网络相关的内容可以参考《TCP/IP详解》卷一<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1099252/">http://book.douban.com/subject/1099252/</a>。</p>
<p>一些更具体的内容，如linux启动过程、linux文件系统原理、浏览器访问网址过程等，可以查看wikipedia相关页面，linux相关的内容可以访问鸟哥的私房菜基础篇的相关文章<a target="_blank" rel="noopener" href="http://linux.vbird.org/linux_basic/">http://linux.vbird.org/linux_basic/</a></p>
<p>尤其是大厂的工作，只看这个肯定是不行的。leetcode肯定是要刷的。而且光刷都是不行的，需要非常多的消化和总结。</p>
<p>只是很多人对于它的期望不太合理。估计不少人期望刷完这本书之后，自己的能力能提升好几个档次，一切都豁然开朗。但是实际结果可能是就连书里刷过的题，都回头就忘了。</p>
<p>这其实很正常，这本书只有189道题，指望这189道题就能涵盖所有考题，本身就是不现实的。但是这189道题确实涵盖了大部分的题型，而且给出了比较常规的解题思路，读者可以根据这些题自己去找其他类似的题，而且也可以根据自己的薄弱环节去强化训练。说到强化训练，geeksforgeeks其实是个好地方。</p>
<p>另外这本书除了题目之外，也给出了一些针对不同编程语言的考点，以及一些系统设计的基础，这些内容几乎都是点到为止，说的很简略。这就更体现了此书的性质，其实就是个提纲。读者如果只是知道这些内容，那面试官只要稍微问的深一点点，马上就露馅了。</p>
<p>让你有一个比较完整清晰的印象，然后基于此去训练自己。</p>
<p>编程本质是思维活动，也是智力活动，重在思考问题的方法和切入问题的角度。</p>
<p>《编程之美》《编程珠玑》《程序员面试指南》</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="The-AWK-Programming-Language"><a href="#The-AWK-Programming-Language" class="headerlink" title="The AWK Programming Language"></a>The AWK Programming Language</h3><p>![](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/The">https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/书籍/The</a> AWK Programming Language.png)</p>
<p>国人的翻译： <a target="_blank" rel="noopener" href="https://github.com/wuzhouhui/awk">https://github.com/wuzhouhui/awk</a></p>
<p><a target="_blank" rel="noopener" href="https://ferd.ca/awk-in-20-minutes.html">Awk in 20 Minutes</a></p>
<h3 id="Linux-UNIX系统编程手册"><a href="#Linux-UNIX系统编程手册" class="headerlink" title="Linux/UNIX系统编程手册"></a>Linux/UNIX系统编程手册</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image043.png"></p>
<p>上下册两组人翻译。下册有很多明显的错误，建议读者对比英文版正确理解。</p>
<p>我是本书的合译者之一，在第四章的翻译过程中将相关内容和APUE作了比对，有些感触：经典的力量就在于将读者的理解成本降至最低，而不是用一堆恐怖的抽象名词让人望而却步。试举一例：synchronized I/O data integration completion，尽管出自SUSv3的定义，看了还是不懂。至于本书的写作手法，由于目前翻译工作还为大范围展开，不便妄加评说</p>
<p>这些所谓的经典其实都根本不需要去看，因为很多国内的书其实更好理解，然后我就对他的论调提出一点：在APUE之前，没有一本书Unix下的系统级编程及其技巧讲得这么全面的了－－－其实在这里也是一样，APUE确实优秀，但它不是完全针对linux的，</p>
<p><a target="_blank" rel="noopener" href="https://www.douban.com/people/2644853">孙嘻嘻</a>：本书作者的英文表达能力通篇都在给读者“设局”，严重影响到了读者对知识的吸收。我们翻译的是上卷。此书的翻译费用为5万元左右，需要历时三年才能到账。我们四人在2011年1月到2012年8间翻译1-34章时（报酬是2.5万元），平均每人每天要在上面消耗4个小时以上，最后实在精疲力竭，以至于不能完整译完本书。我们每人每小时的实际报酬最多6~7元钱。三年里人民币的贬值幅度。至少到目前为止，我们一分钱没有到手。这书既不能让新手入门，对非新手来说又不能降低学习难度（这书许多地方写的都不如手册页，手册页是免费的，这书99.5刀），虽然作者的水平我不否认，但作为一本要花钱去买的书来说，只值1星。</p>
<p>本书不是面向新手的introduction，是handbook啊~~</p>
<p>讲IO模型讲的非常详细，可以重点看看。</p>
<p>本书超越了APUE，尤其是对Linux系统编程中的关键概念讲解特别透彻，</p>
<p>其实相比APUE，我还是更推荐APUE的。就拿原子操作来说，很多深层原理性的东西，这本书讲得都比较含糊，没有一个清晰的定义。而后看了apue后才豁然开朗，讲得很透彻。ps:不要说apue太难看不懂什么的，那只是你没静下心看</p>
<p>如果读过深入了解计算机系统再来看这本书，就非常棒了</p>
<p>英文版+原书Errata食用更佳</p>
<p>个人觉得这本书对于API的解释相比于APUE更为清楚，尤其是对参数的解释，APUE在读的时候，很多参数并没有解释的很清楚，还得上网去查。另外，这本书上册的翻译明显要比下册负责很多。</p>
<p>所有面试问到的关于linux系统编程的问题在这本书里都能快速的找到答案，真是哪里不会点哪里</p>
<p>看的很爽，配合源码简直了，下册的前几章翻译很烂</p>
<p>上下两卷翻译没沟通吧 文件描述符那里说不清</p>
<p>apue 混合服用疗效更好</p>
<p>非常全面的一本介绍linux系统编程（系统调用）接口的书籍，值得一看。</p>
<p>没有操作系统基础的tx，建议配合华文慕课网陈向群老师的公开课《操作系统原理》（如果有空还可以加上陈老师翻译的《现代操作系统》一书）食用，风味更佳~</p>
<p>上册看懂之后再去啃APUE完全不吃力。 </p>
<p>看来楼上也是过来人。其实所谓的man、RFC各种标准，都是内行人写给内行人看的，为求表述精确，可以不用深入浅出。但技术书籍可就不一样了，买过英文原版数的人应该都知道，国外的图书（不论是纸质还是电子）都贵的惊人。而技术书籍的一般用途是帮助水平不如自己（甚至是完全不懂技术）的人提高水平（或入门），因此除了要表述精确以外，还必须要深入浅出。可在我看来，LPI的作者完全是按照论文或man的写作方式在写作，导致此书的阅读门槛极高，作者有许多表述方式可以说是“挫”到了极致。所以，这书对普通的初学者来说只有1星。</p>
<p>资深程序员 才能正确评价这本书， 这本书的一大特点就是细，扣的非常细， 有点过于拘泥于细节，high level的东西有点少。 对于初学者要有人带着读最好。 译者速度也太慢了，转眼2年过去，完成度有多少， 在国内，翻译的价钱是很贱的，别指望靠翻译生活， 存着 传道授业解惑的心搞这个才行，否则不如不翻。</p>
<p>这本书其实是man内容的扩展， 需要细细摩挲，看是看原版的准确些</p>
<h3 id="APUE-UNIX环境高级编程"><a href="#APUE-UNIX环境高级编程" class="headerlink" title="APUE UNIX环境高级编程"></a>APUE UNIX环境高级编程</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image044.png"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image045.png"></p>
<p>这本书告诉你有哪些和内核交互的接口，怎么在这些接口上编程。 但从另一个角度上来说，这本书告诉你在设计一个产品级的操作系统时，需要设计哪些接口，为什么需要设计这些接口，以及为什么要这样设计这些接口。</p>
<p>传说中的Unix编程圣经~历时两周读完第一遍。 很多以前只有模糊理解的概念和Unix(Linux)系统中的实际实现能够对应起来了，印象比较深刻的是：文件/目录的权限控制；多进程/线程写文件的同步性问题；IO多路复用/非阻塞IO；IPC通信；信号中断(信号可重入与多线程可重入)；进程执行与内存结构；用户调用与系统调用；作业控制实现；等等 经典好书，绝对值得反复阅读。</p>
<p>如果你不满足于操作系统书籍那些虚无缥缈的概念，进程，线程，信号，IO…，看完这本书就会有更切实的感受。当然这本书讲的大多也是操作系统提供的接口，但是说明了最核心的原理</p>
<p>api手册</p>
<p>可以挑选一些章节重点阅读，大部分内容作为查阅的资料</p>
<p>U/L系统必读书目。第1-13章可以一次性读透，但第14章后的内容，能明显发现是和UNP两卷书结合在一起的。建议先看UNP两卷再看，会清楚得多，不过个人感觉，学U/L系统基础看前13章就够了，毕竟这本书是个大块头…</p>
<h3 id="UNP-UNIX网络编程"><a href="#UNP-UNIX网络编程" class="headerlink" title="UNP  UNIX网络编程"></a>UNP  UNIX网络编程</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image046.png"></p>
<p>很细节，算是工具书，适合用到的时候查阅。很佩服从头到尾拿来学习的，简直在骗自己。翻译挺差的。</p>
<h3 id="鸟哥的Linux私房菜-基础学习篇-第四版"><a href="#鸟哥的Linux私房菜-基础学习篇-第四版" class="headerlink" title="鸟哥的Linux私房菜 基础学习篇 第四版"></a>鸟哥的Linux私房菜 基础学习篇 第四版</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image047.png"></p>
<p>写的比较友好，不像《UNIX环境高级编程》只适合当手册用。</p>
<p>入门建议先去网上看视频，看完之后再来看一遍这本书，收获颇丰。</p>
<p>比较口语化，代价是结构、逻辑不明晰。不过本身知识就比较碎片化。</p>
<p>适合Linux使用者，对Linux程序员来说这本书还是不够的</p>
<p>更适合没学过计算机的从零开始，实在太啰嗦了。</p>
<p>一厢情愿的“通俗易懂”。文风累人，条理不清，设问成瘾，表达堪忧，根本不懂什么叫归纳总结。示例代码玩花样，排版还一塌糊涂。</p>
<p> 此书看似非常厚，但是真正零基础读完也不到3星期；如果非要用此书入门，建议读得更快些，前面基础章节多花一些时间，后面的的内容知道是干什么的就行了，用到的时候再查手册。</p>
<p>读者没必要一字一句的读，最好飞快的过一遍，有不懂的地方再仔细看作者的解释。</p>
<h3 id="Linux高性能服务器编程"><a href="#Linux高性能服务器编程" class="headerlink" title="Linux高性能服务器编程"></a>Linux高性能服务器编程</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image048.png"></p>
<p>代码硬伤较多，例如非阻塞write没有一次写对。且没有体现“高性能”。</p>
<p>内容覆盖的点很多，但是基本看不到侧重，作者也没有足够的能力撑起这些内容以至于大部分都是没有insight的资料搬运。代码质量比较糟糕，书中错误之处，大大小小的加起来也不少，非常容易误导人。整体上名不副实（高性能、服务器）</p>
<p>(1).不适合入门，涉及面太广。需要再读几遍才能吃透。(2).特别适合有一定的Linuc c/c++服务端经验的人，虽然讲解的很全面，但不太深。不过还是很值得细看几遍的！！</p>
<p>大部分内容APUE和UNP里面都有讲过，不过这本书也讲到了那两本书里面所没有的知识，比如epoll、Reactor/Proactor模式和进程池等东西。</p>
<p>建议一定要自己去用这本书上的思路去做个小项目然后运行成功，比如只支持get方法的HTTP服务器（书上最后一张的项目源码），做一遍和看一遍完全不同。</p>
<p>针布戳。。。对菜鸡很友好。。入门更适合那本韩国人写的。。</p>
<p>只能说入门书吧，讲得还算比较清晰，推荐</p>
<p>这本书花了起码2/3篇幅把APUE，UNP，TCP/IP v1这几本书里面重点知识或者说是面试重点再讲了一遍, 面试前用来复习很好的一本书，也是很基础的书. 感觉这本书讲得比较好的地方有: 几个IO多路复用函数的对比总结, 定时器原理以及几种定时器设计思路(保存定时器的容器+可以充当时钟的部件), 统一事件源的思想, Reactor模式/Proactor模式的介绍等</p>
<p>还不错，知识点选的很实战，模型总结的比较全。代码写的有点烂。</p>
<p>入门读物。两三天可以刷完前11章。</p>
<p>实战部分还是不错的，但网络编程零基础直接上来啃会非常痛苦，建议与UNP同时食用。</p>
<p>这本书算是我第一本网络编程和框架方面的书，之前看过UNP，但它是针对unix的，这个本书更加适合linux的网络编程。很多地方都帮助我重新梳理了一遍，收获很大</p>
<h3 id="Linux多线程服务端编程"><a href="#Linux多线程服务端编程" class="headerlink" title="Linux多线程服务端编程"></a>Linux多线程服务端编程</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image049.png"></p>
<p>需要一定的基础，小白进阶</p>
<p>第九章不能更赞</p>
<p>作者围绕多线程和cpp各主题的经验谈，受用。</p>
<p>本书大部分都由作者的blog文章组成，内容略显杂乱，无组织性，不能算得上是一本好书，9.0的分数由理由相信是水军所为。 但是各章节内容也不能说无任何价值，都是作者的经验之谈。对我进行服务器编程不久的同学来说，还是值得一读的。</p>
<p>这本书展示了使用 C++、多线程进行网络编程的许多最佳实践，甚至称为标准做法也不为过。比如当谈到 C++ 的内存管理问题的时候，以“不配对的 new[]/delete”为例，用“把 new[] 统统替换为 std::vector/scoped_array”为解决方案，提出使用“智能指针”解决大部分内存问题，堪称金玉良言。又比如当谈到“如何限制并发连接数”时，作者直接引用了 libev 作者 Marc Lehmann 提出的几个方案，并另外给出一个更为简单的方案。</p>
<p>这些最佳实践的意义在于，当你读完了 APUE 和 UNP，却发现自己写出来的网络程序完全不堪商用，然后花费了许多日日夜夜修补业务漏洞、内存泄漏、并发性能，勉强支撑了公司业务以后，读到此书时那种相见恨晚的感觉。你会发现虽然自己身经百战，但是仍然能够从书中找到自己完全不了解的“常识”；对你来说，也许最大的欣慰就是觉得以后团队新人终于有一本实践指南，可以让新人快速成长起来，不用再一次趟过你已经趟过的坑。</p>
<p> 这本书展示了好的代码，特别是好的 C++ 代码。从来不缺乏 C++ 的批评之声，但是 C++ 应当怎么用，如何写 C++ 才是现代的、真正的 C++，在此书之前，几乎从来没有成体系的讲法。我参与过一些 C++ 项目的编程，也见过许多技术负责人一边视 boost 为洪水猛兽，甚至对 STL 也避之不及，却又一边自行制造同样目的、质量差强人意的山寨版轮子。作者非常理性地看待 C++，约束自己对其特性的使用，并提出“朴素的 C++ 设计”理念，在编程中挑选 boost 库中久经考验的、优秀的子库善加应用，比如“使用 boost::function 和 boost::bind 取代虚函数”，减少代码的同时获得非常可靠的代码质量，是非常值得我们学习借鉴的。</p>
<p> 这本书展示了基础的重要性。直接读，可以发现很多章节讲的内容都可以说是常识，但是作为一名久经考验的程序员，可以说，我觉得这里面讲的常识都是“一不留神坑死你”的。比如“shared_ptr 技术与陷阱”一节中，作者提到析构的线程不一定是是对象诞生的线程，我的膝盖就中过一箭。当时我为一个动作游戏编写非玩家角色的人工智能，在游戏中，大部分 CPU 资源都被用在图形渲染上，留给人工智能的资源非常有限，我又要做计算量超大的团队人工智能，所以很“卡”。后来的优化方案是把内存释放操作放到另一条线程去执行，虽然当时没有使用 shared_ptr，但因为问题的原因和解决方案都是一样的，如果我们当时都读过这本书，应该不会踏入这个坑。如果有出身草莽的野路子程序员，读一下这本书，应该还是大有补益的。</p>
<p> 这本书展示了对业务理解的重要性。无论是 muduo 库，还是这本书，都没有想做到面面俱到。对于 muduo，作者追求的是完成业务领域的需求，并压榨硬件的极限；对于这本书，作者讲求的是“经验与实践”，并没有把这本书写成枕头书，而是把“应当注意的、我这样做的理由”讲得通透。说老实话，读这本书，感觉到作者就像一对一的培训那么贴心。</p>
<p> 虽然我从 2013 年起，以 web 开发和团队管理工作为主，已经不写基于 TCP 协议的服务器端程序，甚至“几乎不使用 C++”三年了，但阅读这本书仍然极有意义：一是理解 Linux 关于网络方面的新特性，这一块对我现在做基于 HTTP 协议的开发工作也是极有帮助的；二是理解多线程的最佳实践，其实工作中免不了多少要跟多线程打交道，掌握这方面的最佳实践，在遇到使用场景时，可以马上给出“没大错”的方案；三是理解 C++，跟上它的发展，这对于我编写、学习其它编程语言也极有指导意义。当然，对于我朋友这种从客户端转过来服务器端的程序员来说，最重要的是能够快速地写出“正统的”服务器端代码了。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库系统概念"><a href="#数据库系统概念" class="headerlink" title="数据库系统概念"></a>数据库系统概念</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image050.png"></p>
<p> 配合cmu15-445一起学习才不会那么理论化</p>
<p>是一本面面俱到深度不够偏理论性的书，无商业应用案例，实用性较弱。</p>
<p>在索引一章，完全可以通过他的算法加例子很好的理解索引的原理和应用，在查询处理一节，对算法的理解很透彻。</p>
<p>第七版：</p>
<p>7th针对分布式存储和分布式计算进行了大量改进，配合15-445阅读体验极佳</p>
<p>针对近年来分布式存储领域的进展进行了大量重要更新，</p>
<p>由浅入深，逐步进阶，理论指导，多加练习。书籍顺序:入门《Mysql必知必会》，进阶《高性能Mysql》，升华《Mysql技术内幕:innodb存储引擎》。</p>
<h3 id="高性能MYSQL"><a href="#高性能MYSQL" class="headerlink" title="高性能MYSQL"></a>高性能MYSQL</h3><p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image051.png"></p>
<p>关键就是3-6和9-11章，表结构设计，索引，分库分表，EXPLAIN+执行计划。挺全的，不过很多东西都是假设你有清晰的概念，还是配合搜索看最合适</p>
<p>喜欢第三章troubleshooting 的思路和第九章的对于硬件的介绍</p>
<p>书中没有各种提升性能的秘籍，而是深入问题的核心，详细的解释了每种提升性能的原理，从而可以使你四两拨千斤。授之于鱼不如授之于渔，这本书做到了。</p>
<p>翻译一般，对Mysql有个整体认识后再看英文的。翻译烂的像屎一样，有时候一个很简单的问题会说的很复杂难懂。还会看第二遍。</p>
<p>有点吃力的感觉，读了第二章，翻了一般，后面真心看着吃力了，一些优化，视图，复制之类的。</p>
<p>书中的 MySQL版本较旧，可结合 MySQL官方文档阅读</p>
<p>优先：第456章； 其次：第12378910章； 看下附录； 其他章节可忽略。 认真读，一个月就整完了。</p>
<p>适合DBA阅读</p>
<p>读的我头大，且看不懂啥意思。以后有机会重读吧。太详细了。</p>
<p>3,4,5,11,14</p>
<p>开发角度阅读 1、4、5、6 章即可，受益匪浅。</p>
<p>不过内容太琐碎了需要有详略的读。mvcc，锁，索引，分区这几部分阐述的很好，在数据增量远超想象的今天，后部分构建高性能的意义不大 - - -</p>
<p>为了面试，背下了前面四章</p>
<p>非DBA工作人员可以着重阅读4-7章. 遇到问题可以作为工具书查阅</p>
<p>至于开发人员，阅读理解前7章就足够了</p>
<p> <img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/%E4%B9%A6%E7%B1%8D/image052.png"></p>
<p>推荐资料：<br> MySQL必知必会（一本很薄的小册子，不到一周就看完了，看完基本的SQL语句没什么问题了）<br> 高性能MySQL(建议只看索引以及优化这两章，后续的可以慢慢再看，这本书，真的真的很厚。)<br> Redis设计与实现（算是Redis入门资料吧，认真看完的话就对Redis有大概了解了，话说Redis这么火爆是有原因的，其中的一些精妙设计真的看完令人大呼过瘾，不得不承认，人与人之间真是有差距的。。。）<br> 极客时间- Redis核心技术与实战 （中科院的研究员开设的Redis专栏，个人已经买了，非常不错）<br> 另外再推荐基本数据库底层的书籍：数据库系统实现（华东师范大学数据学院指定数据库原理书籍）、MySQL技术内幕 -InnoDB存储引擎（InnoDB的详细剖析）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">pilotqvq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://c-parrot.github.io/2021/05/05/books-reference">https://c-parrot.github.io/2021/05/05/books-reference</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/书籍/QQ截图20210312180709.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/10/niuke-online-judge"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/算法/QQ截图20210509171651.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">牛客网笔试OJ判题系统</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/30/install-program"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/hexo相关/QQ截图20210312175844.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">软件安装</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E9%87%8F%E5%8C%96%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">计算机体系结构：量化研究方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%A1%AC%E4%BB%B6-%E8%BD%AF%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">计算机组成与设计：硬件&#x2F;软件接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">深入理解计算机系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">2.1.</span> <span class="toc-text">设计模式的艺术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Head-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">Head First 设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1"><span class="toc-number">2.3.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">大话设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDD"><span class="toc-number">2.5.</span> <span class="toc-text">DDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%A4%8D%E6%9D%82%E6%80%A7%E5%BA%94%E5%AF%B9%E4%B9%8B%E9%81%93"><span class="toc-number">2.6.</span> <span class="toc-text">领域驱动设计: 软件核心复杂性应对之道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">3.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E8%AF%A6%E8%A7%A3-%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC2%E7%89%88%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">TCP&#x2F;IP详解 卷1：协议（原书第2版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">3.3.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3HTTP"><span class="toc-number">3.4.</span> <span class="toc-text">图解HTTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%93%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">操作系统–精髓与设计原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%EF%BC%9A-Operating-Systems-Three-Easy-Pieces"><span class="toc-number">4.2.</span> <span class="toc-text">操作系统导论： Operating Systems: Three Easy Pieces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC4%E7%89%88%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">现代操作系统（原书第4版）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C"><span class="toc-number">5.</span> <span class="toc-text">C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-1"><span class="toc-number">6.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Primer"><span class="toc-number">6.1.</span> <span class="toc-text">C++ Primer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Primer-Plus"><span class="toc-number">6.2.</span> <span class="toc-text">C Primer Plus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%8AEssential-C-%E3%80%8B"><span class="toc-number">6.3.</span> <span class="toc-text">《Essential C++》</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-%E7%AC%AC2%E7%89%88"><span class="toc-number">6.4.</span> <span class="toc-text">C++标准库(第2版)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E9%80%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">精通正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">正则表达式必知必会</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">8.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E6%88%98"><span class="toc-number">8.1.</span> <span class="toc-text">Redis实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.</span> <span class="toc-text">Redis设计与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4"><span class="toc-number">8.3.</span> <span class="toc-text">Redis开发与运维</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB"><span class="toc-number">9.</span> <span class="toc-text">程序员的自我修养</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">代码大全（第2版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93"><span class="toc-number">9.2.</span> <span class="toc-text">程序员的自我修养 链接、装载与库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB"><span class="toc-number">9.3.</span> <span class="toc-text">代码整洁之道:程序员的职业素养</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%8A%E9%87%8D%E6%9E%84%EF%BC%9A%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B"><span class="toc-number">9.4.</span> <span class="toc-text">《重构：改善既有代码的设计》</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer"><span class="toc-number">10.1.</span> <span class="toc-text">剑指offer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BACLRS"><span class="toc-number">10.2.</span> <span class="toc-text">算法导论CLRS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C"><span class="toc-number">10.4.</span> <span class="toc-text">算法设计手册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">11.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8"><span class="toc-number">11.1.</span> <span class="toc-text">程序员面试宝典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8"><span class="toc-number">11.2.</span> <span class="toc-text">程序员面试金典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-number">12.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-AWK-Programming-Language"><span class="toc-number">12.1.</span> <span class="toc-text">The AWK Programming Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C"><span class="toc-number">12.2.</span> <span class="toc-text">Linux&#x2F;UNIX系统编程手册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APUE-UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">12.3.</span> <span class="toc-text">APUE UNIX环境高级编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNP-UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">12.4.</span> <span class="toc-text">UNP  UNIX网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87-%E7%AC%AC%E5%9B%9B%E7%89%88"><span class="toc-number">12.5.</span> <span class="toc-text">鸟哥的Linux私房菜 基础学习篇 第四版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">12.6.</span> <span class="toc-text">Linux高性能服务器编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">12.7.</span> <span class="toc-text">Linux多线程服务端编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5"><span class="toc-number">13.1.</span> <span class="toc-text">数据库系统概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BDMYSQL"><span class="toc-number">13.2.</span> <span class="toc-text">高性能MYSQL</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By pilotqvq</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'e53a0a1cfef738bdcf12',
      clientSecret: '78d3614c9635daf100666db51131822370f2fa50',
      repo: 'C-Parrot.github.io',
      owner: 'c-parrot',
      admin: ['c-parrot'],
      id: 'b188348ec44a385e129d75b909d0e20a',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>