<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>GAMES101-现代计算机图形学入门 | </title><meta name="author" content="pilotqvq"><meta name="copyright" content="pilotqvq"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GAMES101: 现代计算机图形学入门https:&#x2F;&#x2F;sites.cs.ucsb.edu&#x2F;~lingqi&#x2F;teaching&#x2F;games101.html 课程介绍  本课程将全面而系统地介绍现代计算机图形学的四大组成部分：（1）光栅化成像，（2）几何表示，（3）光的传播理论，以及（4）动画与模拟。每个方面都会从基础原理出发讲解到实际应用，并介绍前沿的理论研究。通过本课程，你可以学习到计算机图形学背">
<meta property="og:type" content="article">
<meta property="og:title" content="GAMES101-现代计算机图形学入门">
<meta property="og:url" content="https://c-parrot.github.io/2021/12/20/games101-overview-of-computer-graphics">
<meta property="og:site_name">
<meta property="og:description" content="GAMES101: 现代计算机图形学入门https:&#x2F;&#x2F;sites.cs.ucsb.edu&#x2F;~lingqi&#x2F;teaching&#x2F;games101.html 课程介绍  本课程将全面而系统地介绍现代计算机图形学的四大组成部分：（1）光栅化成像，（2）几何表示，（3）光的传播理论，以及（4）动画与模拟。每个方面都会从基础原理出发讲解到实际应用，并介绍前沿的理论研究。通过本课程，你可以学习到计算机图形学背">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/GAMES101/鬼灭10.png">
<meta property="article:published_time" content="2021-12-20T11:30:32.000Z">
<meta property="article:modified_time" content="2023-04-22T18:38:58.000Z">
<meta property="article:author" content="pilotqvq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/GAMES101/鬼灭10.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://c-parrot.github.io/2021/12/20/games101-overview-of-computer-graphics"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"HPFFJ9C6DB","apiKey":"78e3e87b096c5c0bff76287be921d775","indexName":"pilotqvq","hits":{"per_page":6},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GAMES101-现代计算机图形学入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-23 02:38:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/hexo相关/无职转生.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">GAMES101-现代计算机图形学入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon fas fa-history"></i><span class="post-meta-label">Updated</span><time datetime="2023-04-22T18:38:58.000Z" title="undefined 2023-04-23 02:38:58">2023-04-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>16min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GAMES101-现代计算机图形学入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="GAMES101-现代计算机图形学入门"><a href="#GAMES101-现代计算机图形学入门" class="headerlink" title="GAMES101: 现代计算机图形学入门"></a>GAMES101: 现代计算机图形学入门</h1><p><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a></p>
<p>课程介绍</p>
<p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/GAMES101/games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8.png"></p>
<p>本课程将全面而系统地介绍现代计算机图形学的四大组成部分：（1）光栅化成像，（2）几何表示，（3）光的传播理论，以及（4）动画与模拟。每个方面都会从基础原理出发讲解到实际应用，并介绍前沿的理论研究。通过本课程，你可以学习到计算机图形学背后的数学和物理知识，并锻炼实际的编程能力。</p>
<p>顾名思义，作为入门，本课程会尽可能的覆盖图形学的方方面面，把每一部分的基本概念都尽可能说清楚，让大家对计算机图形学有一个完整的、自上而下的全局把握。<strong>全局的理解很重要</strong>，学完本课程后，你会了解到<strong>图形学不等于 OpenGL，不等于光线追踪，而是一套生成整个虚拟世界的方法</strong>。从本课程的标题，大家还可以看到“现代”二字，也就是说，这门课所要给大家介绍的都是现代化的知识，也都是<strong>现代图形学工业界需要的图形学基础。</strong></p>
<p>本课程与其它图形学教程还有一个重要的区别，那就是本课程<strong>不会讲授 OpenGL</strong>，甚至不会提及这个概念。本课程所<strong>讲授</strong>的内容是图形学背后的<strong>原理</strong>，而不是如何使用一个特定的图形学 API。在学习完这门课的时候，你一定有能力自己使用 OpenGL 写实时渲染的程序。另外，本课程并不涉及计算机视觉、图像视频处理、深度学习，也不会介绍游戏引擎与三维建模软件的使用。</p>
<h1 id="计算机图形学概述"><a href="#计算机图形学概述" class="headerlink" title="计算机图形学概述"></a><strong>计算机图形学概述</strong></h1><p>课程包括四个部分：</p>
<ul>
<li>光栅化：OpenGL，shader是如何运作的</li>
<li>曲线和曲面</li>
<li>光线追踪</li>
<li>动画/模拟</li>
</ul>
<p>虚拟现实VR，看到的东西都是虚拟的</p>
<p>增强现实AR，在现实世界中增加一些虚拟的东西</p>
<h2 id="计算机视觉VS计算机图形学"><a href="#计算机视觉VS计算机图形学" class="headerlink" title="计算机视觉VS计算机图形学"></a>计算机视觉VS计算机图形学</h2><p>模型-&gt;图像：特指渲染：把这些模型综合在一起考虑，把它给变成一幅图</p>
<p>模型-&gt;模型：模拟</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238732.png"></p>
<h1 id="变换（二维与三维）"><a href="#变换（二维与三维）" class="headerlink" title="变换（二维与三维）"></a>变换（二维与三维）</h1><h2 id="本节内容"><a href="#本节内容" class="headerlink" title="本节内容"></a>本节内容</h2><ul>
<li>Transformation!</li>
<li>Today<br>- Why study transformation<br>- 2D transformations: rotation, scale, shear<br>- Homogeneous coordinates<br>- Composing transforms<br>- 3D transformations</li>
</ul>
<h2 id="Why-study-transformation"><a href="#Why-study-transformation" class="headerlink" title="Why study transformation"></a>Why study transformation</h2><p>Modeling：模型变换</p>
<p>Viewing：视图变换</p>
<h2 id="2D-transformations"><a href="#2D-transformations" class="headerlink" title="2D transformations"></a>2D transformations</h2><h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238733.png"></p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238734.png"></p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238735.png"></p>
<h3 id="Reflection-Matrix"><a href="#Reflection-Matrix" class="headerlink" title="Reflection Matrix"></a>Reflection Matrix</h3><p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238736.png"></p>
<h2 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h2><p>为什么要引入齐次坐标：不希望将平移当成一个特殊的变换。引入齐次坐标的目的，将所有的变换给写成一个矩阵乘以一个向量的形式。</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238737.png"></p>
<p>齐次矩阵对应的仿射变换的顺序：先进行变换，再进行平移</p>
<h2 id="3D-Transformation"><a href="#3D-Transformation" class="headerlink" title="3D Transformation"></a>3D Transformation</h2><p>右手坐标系与左手坐标系</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238738.png"></p>
<p>右手螺旋定则：X叉乘Z，四指伸直指向x，弯曲到z轴（正向）上，这时大拇指的方向即为y轴的正向方向</p>
<p> 右手系中，Z叉乘X得到Y轴的方向</p>
<h1 id="变换（模型、视图、投影）"><a href="#变换（模型、视图、投影）" class="headerlink" title="变换（模型、视图、投影）"></a>变换（模型、视图、投影）</h1><ul>
<li><p>Viewing (观测) transformation</p>
<ul>
<li><p>View (视图) / Camera transformation</p>
</li>
<li><p>Projection (投影) transformation</p>
<ul>
<li>Orthographic (正交) projection</li>
<li>Perspective (透视) projection</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="View-视图-Camera-transformation"><a href="#View-视图-Camera-transformation" class="headerlink" title="View (视图) / Camera transformation"></a>View (视图) / Camera transformation</h2><p>视图变换也称为模型视图变换（ModelView Transformation)。</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238739.png"></p>
<p>视图变换的具体步骤为，先将相机移动到原点位置，然后再做旋转。</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238740.png"></p>
<h2 id="Projection-投影-transformation"><a href="#Projection-投影-transformation" class="headerlink" title="Projection (投影) transformation"></a>Projection (投影) transformation</h2><p>投影：将某一范围深度之间的内容显示到近处的平面上。</p>
<p>投影主要分为正交投影与透视投影。透视投影，有近大远小的性质。</p>
<h3 id="Perspective-Projection（透视投影）"><a href="#Perspective-Projection（透视投影）" class="headerlink" title="Perspective Projection（透视投影）"></a>Perspective Projection（透视投影）</h3><ul>
<li>Most common in Computer Graphics, art, visual system</li>
<li>Further objects are smaller</li>
<li>Parallel lines not parallel; converge to single poin</li>
</ul>
<hr>
<ul>
<li><p>具体步骤</p>
<ol>
<li>将视锥体挤压成长方体（<strong>n -&gt; n, f -&gt; f</strong>，注意深度不变）</li>
<li>再做正交投影，将长方体变换成立方体（[-1,1]^3^)</li>
</ol>
</li>
</ul>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238741.png"></p>
<h2 id="光栅化（三角形的离散化）"><a href="#光栅化（三角形的离散化）" class="headerlink" title="光栅化（三角形的离散化）"></a>光栅化（三角形的离散化）</h2><ul>
<li>Finishing up Viewing<ul>
<li>Viewport transformation</li>
</ul>
</li>
<li>Rasterization<ul>
<li>Different raster displays</li>
<li>Rasterizing a triangle</li>
</ul>
</li>
<li>Occlusions and Visibility</li>
</ul>
<h3 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h3><p>定义视锥需要的两个概念：field-of-view (fovY，垂直可视角度) 和 aspect ratio（长宽比)。</p>
<p>l,r,b,t：分别是近平面的左右上下坐标</p>
<p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/GAMES101/05-%E5%AE%9A%E4%B9%89%E8%A7%86%E9%94%A5.png"></p>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>什么是屏幕：屏幕是一个二维的数组，数组中的一个元素就代表一个像素。</p>
<p>什么是分辨率：数组的大小。例如1920*1080，其分辨率为1080p，表示像素的多少</p>
<p><strong>光栅成像设备</strong>，光栅，是德语中的一个词，意思就是屏幕</p>
<p><strong>光栅化</strong>，rastrize，一个动词，是指<strong>把东西画在屏幕上</strong></p>
<hr>
<p>定义屏幕左下角为原点，一个像素覆盖1个单位，像素的起点是它的index，它的中心点坐标表示该像素。那么整个屏幕覆盖的范围是【0，0】到 [ width, height ] 。</p>
<p>暂时不管z轴，将立方体的xy缩放成屏幕大小，Transform in xy plane: [-1, 1]^2^ to [0, width] x [0, height]</p>
<h3 id="Triangles-Fundamental-Shape-Primitives"><a href="#Triangles-Fundamental-Shape-Primitives" class="headerlink" title="Triangles - Fundamental Shape Primitives"></a>Triangles - Fundamental Shape Primitives</h3><p>四边面方便细分，实际计算的时候还是按三角形进行渲染的</p>
<p>四边形面片可以动态拆分以期获得更好的显示效果，但是显卡只能处理三角面片</p>
<p>三角形内部一定是平面的，三角形内外定义是清晰的，像多边形，如果它里面有”洞“怎么办，如果不是凸多边形怎么办。可以利用向量的叉积来判断一个点是否在三角形内。</p>
<p>知道三角形三个顶点的属性，可以通过插值的方法知道其内部任意一个点的属性，</p>
<p><strong>Why triangles?</strong></p>
<ul>
<li>Most basic polygon<ul>
<li>Break up other polygons</li>
</ul>
</li>
<li>Unique properties<ul>
<li>Guaranteed to be planar</li>
<li>Well-defined interior</li>
<li>Well-defined method for interpolating values at vertices over triangle (barycentric interpolation)</li>
</ul>
</li>
</ul>
<p><strong>如果一个像素在两个三角形共同边上怎么办？</strong></p>
<p>要么不处理，要么特殊处理。自己可以定义一个标准，比如像素只要在边上，就在三角形内，下图在两个三角形内。比如在边界上不算，也没有关系。边上的点画不画其实并不太影响整个图形的最终效果。</p>
<h1 id="着色（光照与基本着色模型）"><a href="#着色（光照与基本着色模型）" class="headerlink" title="着色（光照与基本着色模型）"></a>着色（光照与基本着色模型）</h1><ul>
<li><p>Visibility / occlusion</p>
<ul>
<li>Z-buffering</li>
</ul>
</li>
<li><p>Shading</p>
<ul>
<li>Illumination &amp; Shading</li>
<li>Graphics Pipeline</li>
</ul>
</li>
</ul>
<h2 id="Visibility-occlusion"><a href="#Visibility-occlusion" class="headerlink" title="Visibility / occlusion"></a>Visibility / occlusion</h2><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><p>先把远处的东西画好（画在屏幕上），由远到近依次做光栅化，这样就可以得到正确遮挡的结果。</p>
<p>近的东西覆盖掉远处已经画好的东西。时间复杂度为nlogn，因为需要排序（由远及近）。</p>
<p>缺点：</p>
<ul>
<li>Requires sorting in depth (O(n log n) for n triangles)</li>
<li>Can have unresolvable depth order</li>
</ul>
<p>画家算法无法解决同深度问题，比如画一个立方体，如果按右，上，左，下的顺序渲染面，然后再渲染最前面的一面，最后的结果是多出了两条线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/GAMES101/07-%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95.png"></p>
<h3 id="Z-buffering"><a href="#Z-buffering" class="headerlink" title="Z-buffering"></a>Z-buffering</h3><ul>
<li>每个像素记录所有物体相互叠落之后的最浅深度</li>
<li>Needs an additional buffer for depth values。同步生成两个图像<ul>
<li>一个是最终的结果图，存在frame buffer中</li>
<li>一个是深度图或深度缓存，这个图像只存任何一个像素它所看到的几何物体的最浅的深度的信息，存在depth buffer中</li>
</ul>
</li>
</ul>
<p>这两幅图是同步生成的</p>
<p>利用深度缓存，来维护遮挡信息</p>
<p>深度缓存的一个特点：和顺序无关。不管是先画哪个三角形，只要维护正确的深度值，最后的结果是一致的。（假设这些三角形不在同一深度）。Z-Buffer算法并没有排序的过程，是在找最小值，它的时间复杂度为N</p>
<h2 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h2><p>定义：</p>
<ul>
<li><p>In Merriam-Webster Dictionary：shad·ing, [ˈʃeɪdɪŋ], noun<br>The darkening or coloring of an illustration or diagram with parallel lines or a block of color.</p>
</li>
<li><p>In this course：</p>
<p>The process of applying a material to an object.</p>
</li>
</ul>
<h3 id="Blinn-Phong模型"><a href="#Blinn-Phong模型" class="headerlink" title="Blinn-Phong模型"></a>Blinn-Phong模型</h3><ul>
<li>高光：特别亮的一块</li>
<li>漫反射：相对没有那么剧烈，</li>
<li>环境光：并不是直接光照，而是间接光照，通过别的物体反射接收到的光照。很复杂，环境光简化掉用一个常数表示</li>
</ul>
<p>高光是镜反射，三大面才是漫反射。漫反射和材质颜色相关最大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/GAMES101/07-%E9%AB%98%E5%85%89-%E6%BC%AB%E5%8F%8D%E5%B0%84-%E7%8E%AF%E5%A2%83%E5%85%89.jpg"></p>
<h4 id="Shading-is-Local"><a href="#Shading-is-Local" class="headerlink" title="Shading is Local"></a>Shading is Local</h4><p>着色是局部性的，着色某个点，不考虑其它物体的存在，只考虑对于这个点，光线来的方向，不考虑这个点是否被别的东西挡住了。大家能看到明暗变换，但看不到阴影</p>
<p>Compute light reflected toward camera  at a specific shading point<br>Inputs:</p>
<ul>
<li>Viewer direction, v</li>
<li>Surface normal, n</li>
<li>Light direction, l (for each of many lights)</li>
<li>Surface parameters  (color, shininess, …)</li>
</ul>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238742.jpg"></p>
<h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><ul>
<li><p>光线会被均匀的反射不同的方向。从不同的角度看向某个“点”，其颜色（明暗）都是一样的。</p>
</li>
<li><p>一个表面接收到了多少能量？同一个表面，相对于光方向的不同角度，明暗不同，为什么？</p>
<p>假设光线有一定的能量，考虑某个点周围的单位面积（不然面积的大小影响光的接收大小），第二幅图，旋转后单位面积大小不变。<strong>接收到的能量和 【光照方向和法线方向的夹角的余弦】成正比。</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/GAMES101/07-%E6%8E%A5%E5%8F%97%E5%88%B0%E4%BA%86%E5%A4%9A%E5%B0%91%E8%83%BD%E9%87%8F.jpg"></p>
<ul>
<li><p>有多少能量到达？</p>
<p>在任意一个时刻，点光源辐射出来的光源，能量一定集中在一个球壳上。能量守恒：球壳（（考虑三维空        间））之间的能量相同，离中心越远，球壳上的单位面积上的能量越少，成半径平方的反倍。如果我们知道点光源，和shading point，我们就知道有多少的光传播<strong>到</strong>点光源的附近，我们又知道有多少光在这个点上被吸收</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238743.jpg"></p>
</li>
</ul>
<p>影响明暗的因素：光到达时的能量（离光源的远近），吸收的能量（与光线的夹角），反射了多少光（整体上明亮程度）</p>
<p>漫反射和观察的方向没有关系，这正是因为漫反射从四面八方反射的特点导致的</p>
<h1 id="着色（着色频率、图形管线、纹理映射）"><a href="#着色（着色频率、图形管线、纹理映射）" class="headerlink" title="着色（着色频率、图形管线、纹理映射）"></a>着色（着色频率、图形管线、纹理映射）</h1><ul>
<li>Shading 2<ul>
<li>Blinn-Phong reflectance model<ul>
<li>Specular and ambient terms</li>
</ul>
</li>
<li>Shading frequencies</li>
<li>Graphics pipeline</li>
<li>Texture mapping</li>
<li>Barycentric coordinates</li>
</ul>
</li>
</ul>
<h2 id="高光-Specular-Term（Blinn-Phong）"><a href="#高光-Specular-Term（Blinn-Phong）" class="headerlink" title="高光-Specular Term（Blinn-Phong）"></a>高光-Specular Term（Blinn-Phong）</h2><p>比较光滑的物体，它的反射都有一定的特性，发射的方向接近镜面反射。当观察的方向和镜面反射方向接近时，能够看到高光。</p>
<p>余弦可以体现两个方向是不是足够接近，但是它容忍度太高了。高光应该是非常亮，集中在一个很小的区域，当它们离得非常近，才认为在高光里。公式中p一般值在100-200</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238744.jpg"></p>
<h2 id="环境光-Ambient-Term"><a href="#环境光-Ambient-Term" class="headerlink" title="环境光-Ambient Term"></a>环境光-Ambient Term</h2><p>Shading that does not depend on anything</p>
<ul>
<li>Add constant color to account for disregarded<br>illumination and fill in black shadows</li>
<li>This is approximate / fake!</li>
</ul>
<h2 id="Shading-frequencies"><a href="#Shading-frequencies" class="headerlink" title="Shading frequencies"></a>Shading frequencies</h2><ul>
<li>Flat shading (Shade each triangle)</li>
<li>Gouraud shading：Shade each vertex</li>
<li>Phong shading：Shade each pixel</li>
</ul>
<h2 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射-Texture Mapping"></a>纹理映射-Texture Mapping</h2><p>纹理映射：定义物体上任何一个点上的属性，</p>
<p>三维物体的表面是一个二维的，一个三维物体表面可以和一张图有一一对应的关系。</p>
<p>纹理就是一张图，蒙在三维物体上的表面。三维上的点和纹理上的点的关系。</p>
<p>纹理上坐标，通常用uv。uv范围认为都在0到1范围内（不管长宽比方向）</p>
<hr>
<p>怎么把一个空间上的三角形映射到纹理，我们不管，已经有了这么一个映射关系</p>
<p>映射纹理的两种方法：手动（美术）和自动（参数化，一个非常重要的方向，几何上一个非常厉害的研究）</p>
<h1 id="着色（插值、高级纹理映射）"><a href="#着色（插值、高级纹理映射）" class="headerlink" title="着色（插值、高级纹理映射）"></a>着色（插值、高级纹理映射）</h1><ul>
<li>Shading 3<ul>
<li>Barycentric coordinates</li>
<li>Texture queries</li>
<li>Applications of textures</li>
</ul>
</li>
<li>Shadow mapping</li>
</ul>
<h2 id="Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标"><a href="#Interpolation-Across-Triangles-Barycentric-Coordinates-重心坐标" class="headerlink" title="Interpolation Across Triangles:  Barycentric Coordinates (重心坐标)"></a>Interpolation Across Triangles:  Barycentric Coordinates (重心坐标)</h2><p>Why do we want to interpolate?</p>
<ul>
<li>Specify values at vertices</li>
<li>Obtain smoothly varying values across triangles</li>
</ul>
<p>What do we want to interpolate?</p>
<ul>
<li>Texture coordinates, colors, normal vectors, …</li>
</ul>
<p>How do we interpolate?</p>
<ul>
<li>Barycentric coordinates</li>
</ul>
<p>三角形的重心：把大三角形分成等面的三个小三角形</p>
<p>缺点：在投影下，并不能保证重心坐标不改变。在投影下不变。所以三角形内部的点的属性是在投影之前做的。对于深度测试，光栅化时，找到像素中心点对应的三角形上的点，使用的是它的三维空间下的深度（逆变换，从二维到三维）。在三维空间中做插值，再对应到二维空间的结果上去，根本原因是重心坐标在投影下会发生变化。</p>
<h2 id="Applying-Textures"><a href="#Applying-Textures" class="headerlink" title="Applying Textures"></a>Applying Textures</h2><h3 id="Texture-Magnification：What-if-the-texture-is-too-small？"><a href="#Texture-Magnification：What-if-the-texture-is-too-small？" class="headerlink" title="Texture Magnification：What if the texture is too small？"></a>Texture Magnification：What if the texture is too small？</h3><p>纹理本身太小，比如高分辨率的墙其纹理却很低清。对应的在纹理上的点不是整数。</p>
<p>A pixel on a texture — a texel(纹理元素、纹素)</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238745.jpg"></p>
<h4 id="Bilinear-双线性插值（水平和竖直做两遍插值）"><a href="#Bilinear-双线性插值（水平和竖直做两遍插值）" class="headerlink" title="Bilinear-双线性插值（水平和竖直做两遍插值）"></a>Bilinear-双线性插值（水平和竖直做两遍插值）</h4><p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238746.jpg"></p>
<h4 id="Bicubic"><a href="#Bicubic" class="headerlink" title="Bicubic"></a>Bicubic</h4><p>取周围临近的16的点，每次用4个做三次的插值，不是用线性的插值</p>
<h3 id="Texture-Magnification：What-if-the-texture-is-too-large"><a href="#Texture-Magnification：What-if-the-texture-is-too-large" class="headerlink" title="Texture Magnification：What if the texture is too large?"></a>Texture Magnification：What if the texture is too large?</h3><h1 id="几何（基本表示方法）"><a href="#几何（基本表示方法）" class="headerlink" title="几何（基本表示方法）"></a>几何（基本表示方法）</h1><ul>
<li>Applications of textures</li>
<li>Introduction to geometry (2nd part of this course!)<ul>
<li>Examples of geometry</li>
<li>Various representations of geometry</li>
</ul>
</li>
</ul>
<h2 id="Applications-of-Textures"><a href="#Applications-of-Textures" class="headerlink" title="Applications of Textures"></a>Applications of Textures</h2><p> 纹理可以理解成一块数据，可以做不同类型的查询，没有必要完全限制在一个 “图像”上</p>
<p>In modern GPUs, texture = memory + range query (filtering)</p>
<ul>
<li>General method to bring data to fragment calculations</li>
</ul>
<p>Many applications</p>
<ul>
<li>Environment lighting</li>
<li>Store microgeometry</li>
<li>Procedural textures</li>
<li>Solid modeling</li>
<li>Volume rendering</li>
<li>…</li>
</ul>
<h3 id="Environment-Map"><a href="#Environment-Map" class="headerlink" title="Environment Map"></a>Environment Map</h3><p>环境光照（假设光源无限远，没有实际的深度意义，只保留方向）</p>
<p>可以用纹理表示周围环境光长什么样，可以用这个环境光去渲染其它的物体</p>
<h3 id="Textures-can-affect-shading"><a href="#Textures-can-affect-shading" class="headerlink" title="Textures can affect shading"></a>Textures can affect shading</h3><h4 id="Bump-Mapping"><a href="#Bump-Mapping" class="headerlink" title="Bump Mapping"></a>Bump Mapping</h4><p>应用：凹凸贴图。定义一个任意一个点的相对高度，沿着法线的方向上下移动。表面凹凸不是用三角形表示，通过应用一个复杂的纹理，应用之后法线发生了变化，进而shading发生了变化，从而显示出。</p>
<p>凹凸贴图的原理：人为的做出一个假的法线，通过纹理映射，通过这个假的法线进行shading，可以让人觉得有凹凸不平的结果，但是实际上并没有改变几何。</p>
<p>凹凸贴图和法线贴图是一回事，这取决于贴图定义的是什么，比如左边的图，白色的是0，黑色的是1，定义了点沿着法线虚拟移动的距离。</p>
<p>改变任意一个点的法线</p>
<h2 id="Introduction-to-geometry"><a href="#Introduction-to-geometry" class="headerlink" title="Introduction to geometry"></a>Introduction to geometry</h2><h3 id="Many-Ways-to-Represent-Geometry"><a href="#Many-Ways-to-Represent-Geometry" class="headerlink" title="Many Ways to Represent Geometry"></a>Many Ways to Represent Geometry</h3><p>隐式与显示：用不同的方式来表示不同的几何</p>
<h4 id="Implicit-Representations"><a href="#Implicit-Representations" class="headerlink" title="Implicit Representations"></a>Implicit Representations</h4><p>隐式几何方法：为了表示一个面，不会告诉这些点具体在哪，只告诉这些点满足的关系。满足某种关系的这些点都在这个表面上。把这些点作为一个归类。</p>
<p>隐式表示缺点：不够直观（都有哪些点）</p>
<p>优点：容易判断一个点是否在平面上</p>
<p>Pros:</p>
<ul>
<li>compact description (e.g., a function)</li>
<li>certain queries easy (inside object, distance to surface)</li>
<li>good for ray-to-surface intersection (more later)</li>
<li>for simple shapes, exact description / no sampling error</li>
<li>easy to handle changes in topology (e.g., fluid)</li>
</ul>
<p>Cons:</p>
<ul>
<li>difficult to model complex shapes</li>
</ul>
<hr>
<h4 id="Explicit-Representations"><a href="#Explicit-Representations" class="headerlink" title="Explicit Representations"></a>Explicit Representations</h4><p>显式： 直接给出 或者通过参数映射的方式给出：比如通过遍历UV，然后得到几何图</p>
<p>缺点：难判断一个点在几何的表面与内外。</p>
<h1 id="光线追踪（基本原理）"><a href="#光线追踪（基本原理）" class="headerlink" title="光线追踪（基本原理）"></a>光线追踪（基本原理）</h1><h2 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h2><p>Rasterization couldn’t handle global effects well</p>
<ul>
<li>(Soft) shadows</li>
<li>And especially when the light bounces more than once</li>
</ul>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238747.jpg"></p>
<ul>
<li><p>Rasterization is fast, but quality is relatively low，Ray tracing is accurate, but is very slow</p>
<ul>
<li>Rasterization: real-time, ray tracing: offline</li>
<li>~10K CPU core hours to render one frame in production</li>
</ul>
</li>
</ul>
<p>ray tracing，离线的应用，比如电影</p>
<p>生成一帧，需要1万个CPU运行一个小时</p>
<h2 id="Light-Rays"><a href="#Light-Rays" class="headerlink" title="Light Rays"></a>Light Rays</h2><p>Three ideas about light rays</p>
<ol>
<li>Light travels in straight lines (though this is wrong，光线有波)</li>
<li>两个光线不会发生碰撞(though this is still wrong)</li>
<li>Light rays travel from the light sources to the eye (but the physics is invariant under path reversal - reciprocity，reciprocity，光线的可逆性，假设眼睛反过来，发出光通过反射到达光源).</li>
</ol>
<h2 id="Ray-Casting-Generating-Eye-Rays"><a href="#Ray-Casting-Generating-Eye-Rays" class="headerlink" title="Ray Casting - Generating Eye Rays"></a>Ray Casting - Generating Eye Rays</h2><p>光线从眼睛（现假设一个点）穿过像素到达物体的某个点，然后再从这个点向光源连接。如果有遮挡，说明这个点在阴影中，如果没有，则知道光源方向和视角方向，可以着色了，比如blinn phong模型.</p>
<h2 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h2><p>Whitted-sytle的光线追踪（本身是一个递归），考虑光线弹射多次，比如透明球，就是反生了两次折射，到达眼睛</p>
<p>Whitted-sytle的光线追踪：就是在模拟光线不断弹射的过程。到达一个点之后可以继续传播这条光线，每个弹射点都去和光源做连线，是否被照亮。如果光源可以照亮任何一个弹射的点，这些弹射点都加到同一个像素点上去。会考虑折射（反射)后的能量损失。</p>
<p>Shadow rays:向光源连的，用来判断可见性的</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238748.jpg"></p>
<p>对于透明球，也会到达光源，就可以看到透明球下面的阴影也会浅一些</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238749.png"></p>
<h1 id="动画与模拟（基本概念、质点弹簧系统、运动学）"><a href="#动画与模拟（基本概念、质点弹簧系统、运动学）" class="headerlink" title="动画与模拟（基本概念、质点弹簧系统、运动学）"></a>动画与模拟（基本概念、质点弹簧系统、运动学）</h1><p>Introduction to Computer Animation</p>
<ul>
<li>Keyframe animation</li>
<li>Physical simulation</li>
<li>Kinematics</li>
<li>Rigging</li>
</ul>
<h2 id="Keyframe-Animation"><a href="#Keyframe-Animation" class="headerlink" title="Keyframe Animation"></a>Keyframe Animation</h2><p>关键帧动画是一个插值的技术</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238750.jpg"></p>
<h2 id="Physical-simulation"><a href="#Physical-simulation" class="headerlink" title="Physical simulation"></a>Physical simulation</h2><p>物理模拟:根据正确的物体之间的力，自然就可以模拟正确的效果</p>
<h3 id="Mass-Spring-System"><a href="#Mass-Spring-System" class="headerlink" title="Mass Spring System"></a>Mass Spring System</h3><p>质点弹簧系统：是一系列相互连接的质点和弹簧。基本单元：一个弹簧，左右连接着两个质点</p>
<p>一个理想化的弹簧：没有长度，拉开多长就会产生多大的力</p>
<p>胡克定律：指固體材料受力後，应力与应变成线性关系，满足此定律的材料称为线弹性或虎克型材料。</p>
<h3 id="Particle-Systems"><a href="#Particle-Systems" class="headerlink" title="Particle Systems"></a>Particle Systems</h3><p>粒子系统：一堆很小很小的东西</p>
<p>挑战性：粒子与粒子之间的力，引力，碰撞</p>
<p>Model dynamical systems as collections of large numbers of particles<br>Each particle’s motion is defined by a set of physical (or non-physical) forces<br>Popular technique in graphics and games</p>
<ul>
<li>Easy to understand, implement</li>
<li>Scalable: fewer particles for speed, more<br>for higher complexity</li>
</ul>
<p>Challenges</p>
<ul>
<li>May need many particles (e.g. fluids)</li>
<li>May need acceleration structures (e.g. to<br>find nearest particles for interactions)</li>
</ul>
<h2 id="Kinematics"><a href="#Kinematics" class="headerlink" title="Kinematics"></a>Kinematics</h2><h3 id="Forward-Kinematics"><a href="#Forward-Kinematics" class="headerlink" title="Forward Kinematics"></a>Forward Kinematics</h3><p>给出长度与角度，通过数学计算，得出某个关节点的位置</p>
<p>Strengths</p>
<ul>
<li>Direct control is convenient</li>
<li>Implementation is straightforward</li>
</ul>
<p>Weaknesses</p>
<ul>
<li>Animation may be inconsistent with physics</li>
<li>Time consuming for artists</li>
</ul>
<h3 id="Inverse-Kinematics"><a href="#Inverse-Kinematics" class="headerlink" title="Inverse Kinematics"></a>Inverse Kinematics</h3><p>为了更容易操作。</p>
<p>如可以控制尖端随机移动到某一位置，机器会自动计算相应的变换</p>
<p>反向运动的存在的问题：</p>
<ul>
<li>移动某个点到某位置可能会有多个解，解不唯一</li>
<li>Solutions may not always exist</li>
</ul>
<p>优化方法：通过优化方法去解，而不是真的去解角度</p>
<p>Numerical solution to general N-link IK problem</p>
<ul>
<li>Choose an initial configuration</li>
<li>Define an error metric (e.g. square of distance between goal and current position)</li>
<li>Compute gradient of error as function of configuration</li>
<li>Apply gradient descent (or Newton’s method, or other optimization procedure)</li>
</ul>
<h2 id="rigging：绑定"><a href="#rigging：绑定" class="headerlink" title="rigging：绑定"></a>rigging：绑定</h2><p>Rigging is a set of higher level controls on a character that allow more rapid &amp; intuitive modification of pose, deformations, expression, etc.</p>
<h3 id="The-Production-Pipeline"><a href="#The-Production-Pipeline" class="headerlink" title="The Production Pipeline"></a>The Production Pipeline</h3><p>fX:effect 特效</p>
<p><img src="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/%E5%90%8E%E7%AB%AF/202304230238751.jpg"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">pilotqvq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://c-parrot.github.io/2021/12/20/games101-overview-of-computer-graphics">https://c-parrot.github.io/2021/12/20/games101-overview-of-computer-graphics</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jsdelivr.codeqihan.com/gh/c-parrot/source/img/blog/GAMES101/鬼灭10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/30/ue4-debug"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/UE4/QQ截图20211211175737.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">UE4基础-Debug</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/19/ue4-UMG-dynamic-text"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/c-parrot/source/img/blog/UE4基础/屏幕截图(6).png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">\[UE4]UMG：如何使用动态文本</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">GAMES101: 现代计算机图形学入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">计算机图形学概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89VS%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6"><span class="toc-number">2.1.</span> <span class="toc-text">计算机视觉VS计算机图形学</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%EF%BC%88%E4%BA%8C%E7%BB%B4%E4%B8%8E%E4%B8%89%E7%BB%B4%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">变换（二维与三维）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E8%8A%82%E5%86%85%E5%AE%B9"><span class="toc-number">3.1.</span> <span class="toc-text">本节内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-study-transformation"><span class="toc-number">3.2.</span> <span class="toc-text">Why study transformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D-transformations"><span class="toc-number">3.3.</span> <span class="toc-text">2D transformations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scale"><span class="toc-number">3.3.1.</span> <span class="toc-text">Scale</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflection-Matrix"><span class="toc-number">3.3.2.</span> <span class="toc-text">Reflection Matrix</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Homogeneous-coordinates"><span class="toc-number">3.4.</span> <span class="toc-text">Homogeneous coordinates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D-Transformation"><span class="toc-number">3.5.</span> <span class="toc-text">3D Transformation</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2%EF%BC%88%E6%A8%A1%E5%9E%8B%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8A%95%E5%BD%B1%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">变换（模型、视图、投影）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#View-%E8%A7%86%E5%9B%BE-Camera-transformation"><span class="toc-number">4.1.</span> <span class="toc-text">View (视图) &#x2F; Camera transformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Projection-%E6%8A%95%E5%BD%B1-transformation"><span class="toc-number">4.2.</span> <span class="toc-text">Projection (投影) transformation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Perspective-Projection%EF%BC%88%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">Perspective Projection（透视投影）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%A6%BB%E6%95%A3%E5%8C%96%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">光栅化（三角形的离散化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Perspective-Projection"><span class="toc-number">4.3.1.</span> <span class="toc-text">Perspective Projection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rasterization"><span class="toc-number">4.4.</span> <span class="toc-text">Rasterization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Triangles-Fundamental-Shape-Primitives"><span class="toc-number">4.4.1.</span> <span class="toc-text">Triangles - Fundamental Shape Primitives</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%EF%BC%88%E5%85%89%E7%85%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">着色（光照与基本着色模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Visibility-occlusion"><span class="toc-number">5.1.</span> <span class="toc-text">Visibility &#x2F; occlusion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">画家算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Z-buffering"><span class="toc-number">5.1.2.</span> <span class="toc-text">Z-buffering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shading"><span class="toc-number">5.2.</span> <span class="toc-text">Shading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Blinn-Phong%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">Blinn-Phong模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shading-is-Local"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">Shading is Local</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">漫反射</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%EF%BC%88%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87%E3%80%81%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E3%80%81%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">着色（着色频率、图形管线、纹理映射）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%85%89-Specular-Term%EF%BC%88Blinn-Phong%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">高光-Specular Term（Blinn-Phong）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89-Ambient-Term"><span class="toc-number">6.2.</span> <span class="toc-text">环境光-Ambient Term</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shading-frequencies"><span class="toc-number">6.3.</span> <span class="toc-text">Shading frequencies</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84-Texture-Mapping"><span class="toc-number">6.4.</span> <span class="toc-text">纹理映射-Texture Mapping</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%EF%BC%88%E6%8F%92%E5%80%BC%E3%80%81%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">着色（插值、高级纹理映射）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Interpolation-Across-Triangles-Barycentric-Coordinates-%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87"><span class="toc-number">7.1.</span> <span class="toc-text">Interpolation Across Triangles:  Barycentric Coordinates (重心坐标)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Applying-Textures"><span class="toc-number">7.2.</span> <span class="toc-text">Applying Textures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture-Magnification%EF%BC%9AWhat-if-the-texture-is-too-small%EF%BC%9F"><span class="toc-number">7.2.1.</span> <span class="toc-text">Texture Magnification：What if the texture is too small？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bilinear-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%EF%BC%88%E6%B0%B4%E5%B9%B3%E5%92%8C%E7%AB%96%E7%9B%B4%E5%81%9A%E4%B8%A4%E9%81%8D%E6%8F%92%E5%80%BC%EF%BC%89"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">Bilinear-双线性插值（水平和竖直做两遍插值）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bicubic"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">Bicubic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Texture-Magnification%EF%BC%9AWhat-if-the-texture-is-too-large"><span class="toc-number">7.2.2.</span> <span class="toc-text">Texture Magnification：What if the texture is too large?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%EF%BC%88%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">几何（基本表示方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Applications-of-Textures"><span class="toc-number">8.1.</span> <span class="toc-text">Applications of Textures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Environment-Map"><span class="toc-number">8.1.1.</span> <span class="toc-text">Environment Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Textures-can-affect-shading"><span class="toc-number">8.1.2.</span> <span class="toc-text">Textures can affect shading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bump-Mapping"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">Bump Mapping</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-to-geometry"><span class="toc-number">8.2.</span> <span class="toc-text">Introduction to geometry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Many-Ways-to-Represent-Geometry"><span class="toc-number">8.2.1.</span> <span class="toc-text">Many Ways to Represent Geometry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Implicit-Representations"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">Implicit Representations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Explicit-Representations"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">Explicit Representations</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">光线追踪（基本原理）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Ray-Tracing"><span class="toc-number">9.1.</span> <span class="toc-text">Why Ray Tracing?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Light-Rays"><span class="toc-number">9.2.</span> <span class="toc-text">Light Rays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ray-Casting-Generating-Eye-Rays"><span class="toc-number">9.3.</span> <span class="toc-text">Ray Casting - Generating Eye Rays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Recursive-Whitted-Style-Ray-Tracing"><span class="toc-number">9.4.</span> <span class="toc-text">Recursive (Whitted-Style) Ray Tracing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E4%B8%8E%E6%A8%A1%E6%8B%9F%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E8%B4%A8%E7%82%B9%E5%BC%B9%E7%B0%A7%E7%B3%BB%E7%BB%9F%E3%80%81%E8%BF%90%E5%8A%A8%E5%AD%A6%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">动画与模拟（基本概念、质点弹簧系统、运动学）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Keyframe-Animation"><span class="toc-number">10.1.</span> <span class="toc-text">Keyframe Animation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Physical-simulation"><span class="toc-number">10.2.</span> <span class="toc-text">Physical simulation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mass-Spring-System"><span class="toc-number">10.2.1.</span> <span class="toc-text">Mass Spring System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Particle-Systems"><span class="toc-number">10.2.2.</span> <span class="toc-text">Particle Systems</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kinematics"><span class="toc-number">10.3.</span> <span class="toc-text">Kinematics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Forward-Kinematics"><span class="toc-number">10.3.1.</span> <span class="toc-text">Forward Kinematics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverse-Kinematics"><span class="toc-number">10.3.2.</span> <span class="toc-text">Inverse Kinematics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rigging%EF%BC%9A%E7%BB%91%E5%AE%9A"><span class="toc-number">10.4.</span> <span class="toc-text">rigging：绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Production-Pipeline"><span class="toc-number">10.4.1.</span> <span class="toc-text">The Production Pipeline</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By pilotqvq</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'e53a0a1cfef738bdcf12',
      clientSecret: '78d3614c9635daf100666db51131822370f2fa50',
      repo: 'C-Parrot.github.io',
      owner: 'c-parrot',
      admin: ['c-parrot'],
      id: '79d763d40cf26e2da7c52c968624a75e',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>